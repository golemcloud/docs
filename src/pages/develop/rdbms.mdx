import { Callout, Tabs } from "nextra/components"

# Using Relational Databases

Golem provides an API to integrate with popular relational database systems from any of the supported languages.
The currently supported databases are:

- PostgreSQL
- MySQL

<details>
    <summary>See the full API definition</summary>

    <Tabs items={["TypeScript", "Rust"]} storageKey="nextra-tabs-Rust|TypeScript">
    <Tabs.Tab>
      ```ts
      declare module 'golem:rdbms/types@0.0.1' {
        export type Uuid = {
          highBits: bigint;
          lowBits: bigint;
        };
        export type IpAddress = {
          tag: 'ipv4'
          val: [number, number, number, number]
        } |
        {
          tag: 'ipv6'
          val: [number, number, number, number, number, number, number, number]
        };
        export type MacAddress = {
          octets: [number, number, number, number, number, number];
        };
        export type Date = {
          year: number;
          month: number;
          day: number;
        };
        export type Time = {
          hour: number;
          minute: number;
          second: number;
          nanosecond: number;
        };
        export type Timestamp = {
          date: Date;
          time: Time;
        };
        export type Timestamptz = {
          timestamp: Timestamp;
          offset: number;
        };
        export type Timetz = {
          time: Time;
          offset: number;
        };
      }

      declare module 'golem:rdbms/postgres@0.0.1' {
        import * as golemRdbms001Types from 'golem:rdbms/types@0.0.1';
        export class LazyDbValue {
          constructor(value: DbValue);
          get(): DbValue;
        }
        export class LazyDbColumnType {
          constructor(value: DbColumnType);
          get(): DbColumnType;
        }
        export class DbResultStream {
          getColumns(): DbColumn[];
          getNext(): DbRow[] | undefined;
        }
        export class DbConnection {
          static open(address: string): Result<DbConnection, Error>;
          query(statement: string, params: DbValue[]): Result<DbResult, Error>;
          queryStream(statement: string, params: DbValue[]): Result<DbResultStream, Error>;
          execute(statement: string, params: DbValue[]): Result<bigint, Error>;
          beginTransaction(): Result<DbTransaction, Error>;
        }
        export class DbTransaction {
          query(statement: string, params: DbValue[]): Result<DbResult, Error>;
          queryStream(statement: string, params: DbValue[]): Result<DbResultStream, Error>;
          execute(statement: string, params: DbValue[]): Result<bigint, Error>;
          commit(): Result<void, Error>;
          rollback(): Result<void, Error>;
        }
        export type Date = golemRdbms001Types.Date;
        export type Time = golemRdbms001Types.Time;
        export type Timetz = golemRdbms001Types.Timetz;
        export type Timestamp = golemRdbms001Types.Timestamp;
        export type Timestamptz = golemRdbms001Types.Timestamptz;
        export type Uuid = golemRdbms001Types.Uuid;
        export type IpAddress = golemRdbms001Types.IpAddress;
        export type MacAddress = golemRdbms001Types.MacAddress;
        export type Error = {
          tag: 'connection-failure'
          val: string
        } |
        {
          tag: 'query-parameter-failure'
          val: string
        } |
        {
          tag: 'query-execution-failure'
          val: string
        } |
        {
          tag: 'query-response-failure'
          val: string
        } |
        {
          tag: 'other'
          val: string
        };
        export type Interval = {
          months: number;
          days: number;
          microseconds: bigint;
        };
        export type Int4bound = {
          tag: 'included'
          val: number
        } |
        {
          tag: 'excluded'
          val: number
        } |
        {
          tag: 'unbounded'
        };
        export type Int8bound = {
          tag: 'included'
          val: bigint
        } |
        {
          tag: 'excluded'
          val: bigint
        } |
        {
          tag: 'unbounded'
        };
        export type Numbound = {
          tag: 'included'
          val: string
        } |
        {
          tag: 'excluded'
          val: string
        } |
        {
          tag: 'unbounded'
        };
        export type Tsbound = {
          tag: 'included'
          val: Timestamp
        } |
        {
          tag: 'excluded'
          val: Timestamp
        } |
        {
          tag: 'unbounded'
        };
        export type Tstzbound = {
          tag: 'included'
          val: Timestamptz
        } |
        {
          tag: 'excluded'
          val: Timestamptz
        } |
        {
          tag: 'unbounded'
        };
        export type Datebound = {
          tag: 'included'
          val: Date
        } |
        {
          tag: 'excluded'
          val: Date
        } |
        {
          tag: 'unbounded'
        };
        export type Int4range = {
          start: Int4bound;
          end: Int4bound;
        };
        export type Int8range = {
          start: Int8bound;
          end: Int8bound;
        };
        export type Numrange = {
          start: Numbound;
          end: Numbound;
        };
        export type Tsrange = {
          start: Tsbound;
          end: Tsbound;
        };
        export type Tstzrange = {
          start: Tstzbound;
          end: Tstzbound;
        };
        export type Daterange = {
          start: Datebound;
          end: Datebound;
        };
        export type EnumerationType = {
          name: string;
        };
        export type Enumeration = {
          name: string;
          value: string;
        };
        export type Composite = {
          name: string;
          values: LazyDbValue[];
        };
        export type Domain = {
          name: string;
          value: LazyDbValue;
        };
        export type ValueBound = {
          tag: 'included'
          val: LazyDbValue
        } |
        {
          tag: 'excluded'
          val: LazyDbValue
        } |
        {
          tag: 'unbounded'
        };
        export type ValuesRange = {
          start: ValueBound;
          end: ValueBound;
        };
        export type Range = {
          name: string;
          value: ValuesRange;
        };
        export type DbValue = {
          tag: 'character'
          val: number
        } |
        {
          tag: 'int2'
          val: number
        } |
        {
          tag: 'int4'
          val: number
        } |
        {
          tag: 'int8'
          val: bigint
        } |
        {
          tag: 'float4'
          val: number
        } |
        {
          tag: 'float8'
          val: number
        } |
        {
          tag: 'numeric'
          val: string
        } |
        {
          tag: 'boolean'
          val: boolean
        } |
        {
          tag: 'text'
          val: string
        } |
        {
          tag: 'varchar'
          val: string
        } |
        {
          tag: 'bpchar'
          val: string
        } |
        {
          tag: 'timestamp'
          val: Timestamp
        } |
        {
          tag: 'timestamptz'
          val: Timestamptz
        } |
        {
          tag: 'date'
          val: Date
        } |
        {
          tag: 'time'
          val: Time
        } |
        {
          tag: 'timetz'
          val: Timetz
        } |
        {
          tag: 'interval'
          val: Interval
        } |
        {
          tag: 'bytea'
          val: Uint8Array
        } |
        {
          tag: 'json'
          val: string
        } |
        {
          tag: 'jsonb'
          val: string
        } |
        {
          tag: 'jsonpath'
          val: string
        } |
        {
          tag: 'xml'
          val: string
        } |
        {
          tag: 'uuid'
          val: Uuid
        } |
        {
          tag: 'inet'
          val: IpAddress
        } |
        {
          tag: 'cidr'
          val: IpAddress
        } |
        {
          tag: 'macaddr'
          val: MacAddress
        } |
        {
          tag: 'bit'
          val: boolean[]
        } |
        {
          tag: 'varbit'
          val: boolean[]
        } |
        {
          tag: 'int4range'
          val: Int4range
        } |
        {
          tag: 'int8range'
          val: Int8range
        } |
        {
          tag: 'numrange'
          val: Numrange
        } |
        {
          tag: 'tsrange'
          val: Tsrange
        } |
        {
          tag: 'tstzrange'
          val: Tstzrange
        } |
        {
          tag: 'daterange'
          val: Daterange
        } |
        {
          tag: 'money'
          val: bigint
        } |
        {
          tag: 'oid'
          val: number
        } |
        {
          tag: 'enumeration'
          val: Enumeration
        } |
        {
          tag: 'composite'
          val: Composite
        } |
        {
          tag: 'domain'
          val: Domain
        } |
        {
          tag: 'array'
          val: LazyDbValue[]
        } |
        {
          tag: 'range'
          val: Range
        } |
        {
          tag: 'null'
        };
        export type CompositeType = {
          name: string;
          attributes: [string, LazyDbColumnType][];
        };
        export type DomainType = {
          name: string;
          baseType: LazyDbColumnType;
        };
        export type RangeType = {
          name: string;
          baseType: LazyDbColumnType;
        };
        export type DbColumnType = {
          tag: 'character'
        } |
        {
          tag: 'int2'
        } |
        {
          tag: 'int4'
        } |
        {
          tag: 'int8'
        } |
        {
          tag: 'float4'
        } |
        {
          tag: 'float8'
        } |
        {
          tag: 'numeric'
        } |
        {
          tag: 'boolean'
        } |
        {
          tag: 'text'
        } |
        {
          tag: 'varchar'
        } |
        {
          tag: 'bpchar'
        } |
        {
          tag: 'timestamp'
        } |
        {
          tag: 'timestamptz'
        } |
        {
          tag: 'date'
        } |
        {
          tag: 'time'
        } |
        {
          tag: 'timetz'
        } |
        {
          tag: 'interval'
        } |
        {
          tag: 'bytea'
        } |
        {
          tag: 'uuid'
        } |
        {
          tag: 'xml'
        } |
        {
          tag: 'json'
        } |
        {
          tag: 'jsonb'
        } |
        {
          tag: 'jsonpath'
        } |
        {
          tag: 'inet'
        } |
        {
          tag: 'cidr'
        } |
        {
          tag: 'macaddr'
        } |
        {
          tag: 'bit'
        } |
        {
          tag: 'varbit'
        } |
        {
          tag: 'int4range'
        } |
        {
          tag: 'int8range'
        } |
        {
          tag: 'numrange'
        } |
        {
          tag: 'tsrange'
        } |
        {
          tag: 'tstzrange'
        } |
        {
          tag: 'daterange'
        } |
        {
          tag: 'money'
        } |
        {
          tag: 'oid'
        } |
        {
          tag: 'enumeration'
          val: EnumerationType
        } |
        {
          tag: 'composite'
          val: CompositeType
        } |
        {
          tag: 'domain'
          val: DomainType
        } |
        {
          tag: 'array'
          val: LazyDbColumnType
        } |
        {
          tag: 'range'
          val: RangeType
        };
        export type DbColumn = {
          ordinal: bigint;
          name: string;
          dbType: DbColumnType;
          dbTypeName: string;
        };
        /**
         * A single row of values
         */
        export type DbRow = {
          values: DbValue[];
        };
        export type DbResult = {
          columns: DbColumn[];
          rows: DbRow[];
        };
        export type Result<T, E> = { tag: 'ok', val: T } | { tag: 'err', val: E };
      }

      declare module 'golem:rdbms/mysql@0.0.1' {
        import * as golemRdbms001Types from 'golem:rdbms/types@0.0.1';
        export class DbResultStream {
          getColumns(): DbColumn[];
          getNext(): DbRow[] | undefined;
        }
        export class DbConnection {
          static open(address: string): Result<DbConnection, Error>;
          query(statement: string, params: DbValue[]): Result<DbResult, Error>;
          queryStream(statement: string, params: DbValue[]): Result<DbResultStream, Error>;
          execute(statement: string, params: DbValue[]): Result<bigint, Error>;
          beginTransaction(): Result<DbTransaction, Error>;
        }
        export class DbTransaction {
          query(statement: string, params: DbValue[]): Result<DbResult, Error>;
          queryStream(statement: string, params: DbValue[]): Result<DbResultStream, Error>;
          execute(statement: string, params: DbValue[]): Result<bigint, Error>;
          commit(): Result<void, Error>;
          rollback(): Result<void, Error>;
        }
        export type Date = golemRdbms001Types.Date;
        export type Time = golemRdbms001Types.Time;
        export type Timestamp = golemRdbms001Types.Timestamp;
        export type Error = {
          tag: 'connection-failure'
          val: string
        } |
        {
          tag: 'query-parameter-failure'
          val: string
        } |
        {
          tag: 'query-execution-failure'
          val: string
        } |
        {
          tag: 'query-response-failure'
          val: string
        } |
        {
          tag: 'other'
          val: string
        };
        export type DbColumnType = {
          tag: 'boolean'
        } |
        {
          tag: 'tinyint'
        } |
        {
          tag: 'smallint'
        } |
        {
          tag: 'mediumint'
        } |
        {
          tag: 'int'
        } |
        {
          tag: 'bigint'
        } |
        {
          tag: 'tinyint-unsigned'
        } |
        {
          tag: 'smallint-unsigned'
        } |
        {
          tag: 'mediumint-unsigned'
        } |
        {
          tag: 'int-unsigned'
        } |
        {
          tag: 'bigint-unsigned'
        } |
        {
          tag: 'float'
        } |
        {
          tag: 'double'
        } |
        {
          tag: 'decimal'
        } |
        {
          tag: 'date'
        } |
        {
          tag: 'datetime'
        } |
        {
          tag: 'timestamp'
        } |
        {
          tag: 'time'
        } |
        {
          tag: 'year'
        } |
        {
          tag: 'fixchar'
        } |
        {
          tag: 'varchar'
        } |
        {
          tag: 'tinytext'
        } |
        {
          tag: 'text'
        } |
        {
          tag: 'mediumtext'
        } |
        {
          tag: 'longtext'
        } |
        {
          tag: 'binary'
        } |
        {
          tag: 'varbinary'
        } |
        {
          tag: 'tinyblob'
        } |
        {
          tag: 'blob'
        } |
        {
          tag: 'mediumblob'
        } |
        {
          tag: 'longblob'
        } |
        {
          tag: 'enumeration'
        } |
        {
          tag: 'set'
        } |
        {
          tag: 'bit'
        } |
        {
          tag: 'json'
        };
        export type DbColumn = {
          ordinal: bigint;
          name: string;
          dbType: DbColumnType;
          dbTypeName: string;
        };
        /**
         * Value descriptor for a single database value
         */
        export type DbValue = {
          tag: 'boolean'
          val: boolean
        } |
        {
          tag: 'tinyint'
          val: number
        } |
        {
          tag: 'smallint'
          val: number
        } |
        {
          tag: 'mediumint'
          val: number
        } |
        {
          tag: 'int'
          val: number
        } |
        {
          tag: 'bigint'
          val: bigint
        } |
        {
          tag: 'tinyint-unsigned'
          val: number
        } |
        {
          tag: 'smallint-unsigned'
          val: number
        } |
        {
          tag: 'mediumint-unsigned'
          val: number
        } |
        {
          tag: 'int-unsigned'
          val: number
        } |
        {
          tag: 'bigint-unsigned'
          val: bigint
        } |
        {
          tag: 'float'
          val: number
        } |
        {
          tag: 'double'
          val: number
        } |
        {
          tag: 'decimal'
          val: string
        } |
        {
          tag: 'date'
          val: Date
        } |
        {
          tag: 'datetime'
          val: Timestamp
        } |
        {
          tag: 'timestamp'
          val: Timestamp
        } |
        {
          tag: 'time'
          val: Time
        } |
        {
          tag: 'year'
          val: number
        } |
        {
          tag: 'fixchar'
          val: string
        } |
        {
          tag: 'varchar'
          val: string
        } |
        {
          tag: 'tinytext'
          val: string
        } |
        {
          tag: 'text'
          val: string
        } |
        {
          tag: 'mediumtext'
          val: string
        } |
        {
          tag: 'longtext'
          val: string
        } |
        {
          tag: 'binary'
          val: Uint8Array
        } |
        {
          tag: 'varbinary'
          val: Uint8Array
        } |
        {
          tag: 'tinyblob'
          val: Uint8Array
        } |
        {
          tag: 'blob'
          val: Uint8Array
        } |
        {
          tag: 'mediumblob'
          val: Uint8Array
        } |
        {
          tag: 'longblob'
          val: Uint8Array
        } |
        {
          tag: 'enumeration'
          val: string
        } |
        {
          tag: 'set'
          val: string
        } |
        {
          tag: 'bit'
          val: boolean[]
        } |
        {
          tag: 'json'
          val: string
        } |
        {
          tag: 'null'
        };
        /**
         * A single row of values
         */
        export type DbRow = {
          values: DbValue[];
        };
        export type DbResult = {
          columns: DbColumn[];
          rows: DbRow[];
        };
        export type Result<T, E> = { tag: 'ok', val: T } | { tag: 'err', val: E };
      }
      ```
    </Tabs.Tab>


      <Tabs.Tab>
          ```rust
          mod rdbms {
            pub struct Uuid {
                pub high_bits: u64,
                pub low_bits: u64,
            }

            pub enum IpAddress {
               Ipv4((u8, u8, u8, u8)),
               Ipv6((u16, u16, u16, u16, u16, u16, u16, u16)),
            }

            pub struct MacAddress {
                pub octets: (u8, u8, u8, u8, u8, u8,),
            }


            pub struct Date {
                pub year: i32,
                pub month: u8,
                pub day: u8,
            }

            pub struct Time {
                pub hour: u8,
                pub minute: u8,
                pub second: u8,
                pub nanosecond: u32,
            }

            pub struct Timestamp {
                pub date: Date,
                pub time: Time,
            }

            pub struct Timestamptz {
                pub timestamp: Timestamp,
                pub offset: i32,
            }

            pub struct Timetz {
                pub time: Time,
                pub offset: i32,
            }
          }

          mod postgres {
            use rdbms::*;

            pub struct LazyDbValue {
                handle: Resource<LazyDbValue>,
            }

            pub struct LazyDbColumnType {
                handle: Resource<LazyDbColumnType>,
            }

            pub struct DbResultStream {
                handle: Resource<DbResultStream>,
            }

            pub struct DbConnection {
                handle: Resource<DbConnection>,
            }

            pub enum Error {
                ConnectionFailure(String),
                QueryParameterFailure(String),
                QueryExecutionFailure(String),
                QueryResponseFailure(String),
                Other(String),
            }

            pub struct Interval {
                pub months: i32,
                pub days: i32,
                pub microseconds: i64,
            }

            pub enum Int4bound {
                Included(i32),
                Excluded(i32),
                Unbounded,
            }

            pub enum Int8bound {
                Included(i64),
                Excluded(i64),
                Unbounded,
            }

            pub enum Numbound {
                Included(String),
                Excluded(String),
                Unbounded,
            }

            pub enum Tsbound {
                Included(Timestamp),
                Excluded(Timestamp),
                Unbounded,
            }

            pub enum Tstzbound {
                Included(Timestamptz),
                Excluded(Timestamptz),
                Unbounded,
            }

            pub enum Datebound {
                Included(Date),
                Excluded(Date),
                Unbounded,
            }

            pub struct Int4range {
                pub start: Int4bound,
                pub end: Int4bound,
            }

            pub struct Int8range {
                pub start: Int8bound,
                pub end: Int8bound,
            }

            pub struct Numrange {
                pub start: Numbound,
                pub end: Numbound,
            }

            pub struct Tsrange {
                pub start: Tsbound,
                pub end: Tsbound,
            }

            pub struct Tstzrange {
                pub start: Tstzbound,
                pub end: Tstzbound,
            }

            pub struct Daterange {
                pub start: Datebound,
                pub end: Datebound,
            }

            pub struct EnumerationType {
                pub name: String,
            }

            pub struct Enumeration {
                pub name: String,
                pub value: String,
            }

            pub struct LazyDbValue {
                handle: Resource<LazyDbValue>,
            }

            pub struct Composite {
                pub name: String,
                pub values: Vec<LazyDbValue>,
            }

            pub struct Domain {
                pub name: String,
                pub value: LazyDbValue,
            }

            pub enum ValueBound {
                Included(LazyDbValue),
                Excluded(LazyDbValue),
                Unbounded,
            }

            pub struct ValuesRange {
                pub start: ValueBound,
                pub end: ValueBound,
            }

            pub struct Range {
                pub name: String,
                pub value: ValuesRange,
            }

            pub enum DbValue {
                Character(i8),
                Int2(i16),
                Int4(i32),
                Int8(i64),
                Float4(f32),
                Float8(f64),
                Numeric(String),
                Boolean(bool),
                Text(String),
                Varchar(String),
                Bpchar(String),
                Timestamp(Timestamp),
                Timestamptz(Timestamptz),
                Date(Date),
                Time(Time),
                Timetz(Timetz),
                Interval(Interval),
                Bytea(Vec::<u8>),
                Json(String),
                Jsonb(String),
                Jsonpath(String),
                Xml(String),
                Uuid(Uuid),
                Inet(IpAddress),
                Cidr(IpAddress),
                Macaddr(MacAddress),
                Bit(Vec::<bool>),
                Varbit(Vec::<bool>),
                Int4range(Int4range),
                Int8range(Int8range),
                Numrange(Numrange),
                Tsrange(Tsrange),
                Tstzrange(Tstzrange),
                Daterange(Daterange),
                Money(i64),
                Oid(u32),
                Enumeration(Enumeration),
                Composite(Composite),
                Domain(Domain),
                Array(Vec::<LazyDbValue>),
                Range(Range),
                Null,
            }

            pub struct LazyDbColumnType {
                handle: Resource<LazyDbColumnType>,
            }

            pub struct CompositeType {
                pub name: String,
                pub attributes: Vec::<(String, LazyDbColumnType,)>,
            }

            pub struct DomainType {
                pub name: _rt::String,
                pub base_type: LazyDbColumnType,
            }

            pub struct RangeType {
                pub name: _rt::String,
                pub base_type: LazyDbColumnType,
            }

            pub struct CompositeType {
                pub name: _rt::String,
                pub attributes: _rt::Vec::<(_rt::String, LazyDbColumnType,)>,
            }

            pub struct DomainType {
                pub name: String,
                pub base_type: LazyDbColumnType,
            }

            pub struct RangeType {
                pub name: String,
                pub base_type: LazyDbColumnType,
            }

           pub enum DbColumnType {
               Character,
               Int2,
               Int4,
               Int8,
               Float4,
               Float8,
               Numeric,
               Boolean,
               Text,
               Varchar,
               Bpchar,
               Timestamp,
               Timestamptz,
               Date,
               Time,
               Timetz,
               Interval,
               Bytea,
               Uuid,
               Xml,
               Json,
               Jsonb,
               Jsonpath,
               Inet,
               Cidr,
               Macaddr,
               Bit,
               Varbit,
               Int4range,
               Int8range,
               Numrange,
               Tsrange,
               Tstzrange,
               Daterange,
               Money,
               Oid,
               Enumeration(EnumerationType),
               Composite(CompositeType),
               Domain(DomainType),
               Array(LazyDbColumnType),
               Range(RangeType),
           }

            pub struct DbColumn {
                pub ordinal: u64,
                pub name: String,
                pub db_type: DbColumnType,
                pub db_type_name: String,
            }

            pub struct DbRow {
                pub values:Vec::<DbValue>,
            }

            pub struct DbResult {
                pub columns: Vec::<DbColumn>,
                pub rows: Vec::<DbRow>,
            }
          }

          mod msql {
            use rdbms::*;

            pub struct DbResultStream {
                handle: Resource<DbResultStream>,
            }

            pub struct DbConnection {
                handle: Resource<DbConnection>,
            }

            pub struct DbTransaction {
                handle: Resource<DbTransaction>,
            }

            pub enum Error {
                ConnectionFailure(String),
                QueryParameterFailure(String),
                QueryExecutionFailure(String),
                QueryResponseFailure(String),
                Other(String),
            }

            pub enum DbColumnType {
                Boolean,
                Tinyint,
                Smallint,
                Mediumint,
                Int,
                Bigint,
                TinyintUnsigned,
                SmallintUnsigned,
                MediumintUnsigned,
                IntUnsigned,
                BigintUnsigned,
                Float,
                Double,
                Decimal,
                Date,
                Datetime,
                Timestamp,
                Time,
                Year,
                Fixchar,
                Varchar,
                Tinytext,
                Text,
                Mediumtext,
                Longtext,
                Binary,
                Varbinary,
                Tinyblob,
                Blob,
                Mediumblob,
                Longblob,
                Enumeration,
                Set,
                Bit,
                Json,
            }

            pub struct DbColumn {
                pub ordinal: u64,
                pub name: _rt::String,
                pub db_type: DbColumnType,
                pub db_type_name: _rt::String,
            }

            pub enum DbValue {
                Boolean(bool),
                Tinyint(i8),
                Smallint(i16),
                Mediumint(i32),
                Int(i32),
                Bigint(i64),
                TinyintUnsigned(u8),
                SmallintUnsigned(u16),
                MediumintUnsigned(u32),
                IntUnsigned(u32),
                BigintUnsigned(u64),
                Float(f32),
                Double(f64),
                Decimal(_rt::String),
                Date(Date),
                Datetime(Timestamp),
                Timestamp(Timestamp),
                Time(Time),
                Year(u16),
                Fixchar(String),
                Varchar(String),
                Tinytext(String),
                Text(String),
                Mediumtext(String),
                Longtext(String),
                Binary(Vec::<u8>),
                Varbinary(Vec::<u8>),
                Tinyblob(Vec::<u8>),
                Blob(Vec::<u8>),
                Mediumblob(Vec::<u8>),
                Longblob(Vec::<u8>),
                Enumeration(String),
                Set(String),
                Bit(Vec::<bool>),
                Json(String),
                Null,
            }

            pub struct DbRow {
                pub values: Vec::<DbValue>,
            }

            pub struct DbResult {
                pub columns: Vec<DbColumn>,
                pub rows: Vec<DbRow>,
            }
          }
          ```
        </Tabs.Tab>

    </Tabs>
</details>

### Executing SQL statements

To execute an SQL statement with `golem-rdbms`, first crete a `db-connection` resource and call `execute` on it:

#### MySQL
<Tabs items={["TypeScript", "Rust"]} storageKey="nextra-tabs-Rust|TypeScript">
  <Tabs.Tab>
  ```typescript
  import { DbConnection } from "golem:rdbms/mysql@0.0.1";

  // Connecting to the database called 'test' with user 'root'
  const conn = DbConnection.open("mysql://root@localhost:3306/test");
  conn.execute(
    `CREATE TABLE IF NOT EXISTS test_users
      (
          user_id             varchar(25)    NOT NULL,
          name                varchar(255)    NOT NULL,
          created_on          timestamp NOT NULL DEFAULT NOW(),
          PRIMARY KEY (user_id)
            );`, [])
  ```

  <Callout type="info">
  The functions in the `golem:rdbms/mysql@0.0.1` module are **not async**. This is due to a limitation of the current Golem runtime, and are subject to change in future releases.
  </Callout>
  </Tabs.Tab>

  <Tabs.Tab>
  ```rust
  use golem_rust::bindings::golem::rdbms::mysql::*;

  // Connecting to the database called 'test' with user 'root'
  // Use appropriate error handling in real code
  let conn = DbConnection::open("mysql://root@localhost:3306/test").expect("Failed to connect to database");

  conn.execute(
    "CREATE TABLE IF NOT EXISTS test_users
      (
          user_id             varchar(25)    NOT NULL,
          name                varchar(255)    NOT NULL,
          created_on          timestamp NOT NULL DEFAULT NOW(),
          PRIMARY KEY (user_id)
            );", &[])
  ```

  <Callout type="info">
  The functions in the `golem::rdbms::mysql` are **not async**. This is due to a limitation of the current Golem runtime, and are subject to change in future releases.
  </Callout>
  </Tabs.Tab>

</Tabs>

#### PostgreSQL

<Tabs items={["TypeScript", "Rust"]} storageKey="nextra-tabs-Rust|TypeScript">
  <Tabs.Tab>
  ```typescript
  import { DbConnection } from "golem:rdbms/postgres@0.0.1";

  // Connecting to the database called 'test' with user 'user'
  const conn = DbConnection.open("postgres://user@localhost:5432/test");
  conn.execute(
    `CREATE TABLE IF NOT EXISTS test_users
      (
          user_id             varchar(25)    NOT NULL,
          name                varchar(255)    NOT NULL,
          created_on          timestamp NOT NULL DEFAULT NOW(),
          PRIMARY KEY (user_id)
            );`, [])
  ```

  <Callout type="info">
    The functions in the `golem:rdbms/postgres@0.0.1` module are **not async**. This is due to a limitation of the current Golem runtime, and are subject to change in future releases.
  </Callout>
  </Tabs.Tab>

    <Tabs.Tab>
    ```rust
    use golem_rust::bindings::golem::rdbms::postgres::*;

    // Connecting to the database called 'test' with user 'user'
    // Use appropriate error handling in real code
    let conn = DbConnection::open("postgres://user@localhost:5432/test").expect("Failed to connect to database");

    conn.execute(
      "CREATE TABLE IF NOT EXISTS test_users
        (
            user_id             varchar(25)    NOT NULL,
            name                varchar(255)    NOT NULL,
            created_on          timestamp NOT NULL DEFAULT NOW(),
            PRIMARY KEY (user_id)
              );", vec![])
    ```

    <Callout type="info">
      The functions in the `golem::rdbms::postgres` module are **not async**. This is due to a limitation of the current Golem runtime, and are subject to change in future releases.
    </Callout>
    </Tabs.Tab>
</Tabs>

#### API

Additionally you can:

- `query` executes a SQL statement and returns a result
- `query-stream` executs a SQL statement and returns a streaming result
- `begin-transaction` creates a transaction resource on which, in addition to the `query` and `execute` functions, there is also a `commit` and a `rollback` method.

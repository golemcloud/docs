import { Tabs } from "nextra/components"

# Agent to Agent communication

See the [Agent to Agent communication page](/concepts/agent-to-agent-communication) for a general overview of how agents can invoke each other in Golem.

## Code-first approach

When defining an _agent_ in code, this automatically defines a client interface for calling remote agents as well. This way an agent of an agent type can create other agents and invoke methods on them. The target agent can be of any agent type available for the caller agent in code.

The simplest way to achieve this is to keep all the agent types that need to call each other in the same _component_. Otherwise the agent definition need to be extracted to some shared place and imported to all components involved.

## Creating a client

The first step of calling a remote agent is creating a _client_ for it by specifying which agent type it is and identifying the agent by providing values for its constructor parameters. If the agent identified by the parameters has not been existing yet, it is going to be created and its constructor is executed remotely. If it has been already created, the client just points to it and no action is taken until an _agent method_ is called using it.

<Tabs items={["TypeScript", "Rust"]} storageKey="nextra-tabs-Rust|TypeScript">
    <Tabs.Tab>
In the following example, we have two agents defined; a weather agent with a constructor parameter identifying a location, and another example agent creating and calling this weather agent.

        ```typescript
        @agent()
        class WeatherAgent extends BaseAgent {
            constructor(location: string) {
                super();
                // ...
            }

            @description("Gets the current weather")
            async currentWeather(): Promise<string> {
                // ...
            }
        }

        @agent()
        class ExampleAgent extends BaseAgent {
            constructor() {
                super();
            }

            async run() {
                const weatherInLondon = WeatherAgent.get("London")
                // ...
            }
        }
        ```

        Here `weatherInLondon` is the client for calling a remote `WeatherAgent` - it exposes the agent methods, such as `currentWeather` as its own methods.
    </Tabs.Tab>

    <Tabs.Tab>
In the following example, we have two agents defined; a weather agent with a constructor parameter identifying a location, and another example agent creating and calling this weather agent.

```rust
use golem_rust::{agent_definition, agent_implementation};

#[agent_definition]
pub trait WeatherAgent {
    fn new(location: String) -> Self;
    async fn current_weather(&self) -> String;
}

struct WeatherAgentImpl {
    name: String,
}

#[agent_implementation]
impl WeatherAgent for WeatherAgentImpl {
    fn new(location: String) -> Self {
        // ...
    }

    async fn current_weather(&self) -> String {
        // ...
    }
}

#[agent_definition]
trait ExampleAgent {
    fn new() -> Self;
    async fn run(&self, request: String);
}

struct ExampleAgentImpl;

#[agent_implementation]
impl ExampleAgent for ExampleAgentImpl {
    fn new() -> Self {
        ExampleAgentImpl
    }

    async fn run(&self, request: String) {
        let weather_in_london = WeatherAgentClient::get("london".to_string());
        // ...
    }
}
```

Given there is a `WeatherAgent` defined, we have an auto generated client with the name `WeatherAgentClient`,
Here `weather_in_london` is the client for calling a remote `WeatherAgent` - it exposes the agent methods, such as `current_weather` as its own methods.

    </Tabs.Tab>
</Tabs>

### Phantom agents
Calling `get` **gets or creates** an agent identified by its constructor parameters. Sometimes we want to create more than one instance of the same agent (having the same constructor parameter values), especially when using **ephemeral agents**. Every possible agent has a "default" instance which is normally created by calling `get` on the client or by referring to it using the **agent ID** and can have an arbitrary number of **phantom** instances, distinguished by an additional **phantom ID** UUID. 

When using **agent ID*s (for example in APIs or the CLI), phantom IDs are appended to the agent ID in square brackets:
- Primary instance of `weather-agent` with parameter `London`: 
  - `weather-agent("London")`
- A phantom instance of the same agent: 
  - `weather-agent("London")[43d9d7ab-e1d7-47e2-a213-d635eaa317a2]`

Phantom agents are created through Agent-to-Agent communication or [forking](forking.mdx). To create a new phantom agent via RPC, use the alternative client constructor method:

<Tabs items={["TypeScript", "Rust"]} storageKey="nextra-tabs-Rust|TypeScript">
  <Tabs.Tab>
  ```typescript
  const phantomAgent = WeatherAgent.newPhantom("London")
  ````
  </Tabs.Tab>
  <Tabs.Tab>
    ```rust
    let phantom_agent = WeatherAgentClient::new_phantom("London");
    ```
    </Tabs.Tab>
</Tabs>

If we know the **phantom ID** of an agent, we can create a client targeting an existing phantom agent:

<Tabs items={["TypeScript", "Rust"]} storageKey="nextra-tabs-Rust|TypeScript">
  <Tabs.Tab>
  ```typescript
  const phantomAgent = WeatherAgent.newPhantom("London")
  const phantomId = phantomAgent.getPhantomId();
  const samePhantomAgent = WeatherAgent.getPhantom(phantomId, "London");
  ```
  </Tabs.Tab>
  <Tabs.Tab>
    ```rust
    let phantom_agent = WeatherAgentClient::new_phantom("London");
    let phantom_id = phantom_agent.phantom_id().unwrap(); // It's an Option<Uuid>, but always Some for phantom agents
    let same_phantom_agent = WeatherAgentClient::get_phantom(phantom_id, "London");
    ```
  </Tabs.Tab>
</Tabs>

## Calling a remote agent method

Once we have a _client_ for a remote agent, it is possible to call its methods just as if it would be a local instance.

<Tabs items={["TypeScript", "Rust"]} storageKey="nextra-tabs-Rust|TypeScript">
    <Tabs.Tab>
    ```typescript
    const currentWeather = await weatherInLondon.currentWeather();
    ```
    </Tabs.Tab>

     <Tabs.Tab>
     ```rust
      let current_weather = weather_in_london.current_weather().await;
      ```
     </Tabs.Tab>
</Tabs>

## Triggering execution of an agent method
It is possible to trigger the remote execution of an agent method without awaiting it. This is useful for spawning background tasks, for example.

<Tabs items={["TypeScript", "Rust"]} storageKey="nextra-tabs-Rust|TypeScript">
    <Tabs.Tab>
    To trigger an agent method and return immediately, use the `trigger` method exposed on each remote method in the client:

    ```typescript
    const remoteAgent = BackgroundTaskAgent.get(backgroundJobId);
    remoteAgent.runTask.trigger("hello", 1234);
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    To trigger an agent method and return immediately, use the `trigger` variant of the methods exposed on each remote method in the client.as
    Example: If there is a `run_task`, its trigger variant is `trigger_run_task`:

    ```rust
    let remote_agent = BackgroundTaskAgentClient::get(background_job_id);
    remote_agent.trigger_run_task("hello", 1234);
    ```
    </Tabs.Tab>
</Tabs>

### Scheduling an agent method
An advanced case of triggering the execution of an agent method is to **schedule it** to be executed at a later time.

<Tabs items={["TypeScript", "Rust"]} storageKey="nextra-tabs-Rust|TypeScript">
    <Tabs.Tab>
    Similar to `.trigger`, there is a `.schedule` method as well on each remote agent method in the client:

    ```typescript
    const remoteAgent = BackgroundTaskAgent.get(backgroundJobId);
    remoteAgent.runTask.schedule({ seconds: X, nanoseconds: Y }, "hello", 1234);
    ```

    Here the first parameter is a `Datetime` object, with seconds and nanoseconds fields representing the UNIX Epoch time when the method should be executed. The rest of the parameters are the same as for the original method.

    </Tabs.Tab>

      <Tabs.Tab>
        Similar to `trigger`, there is a `schedule` variant for each of the remote agent method in the client.
        Example: If `run_task` is a method, its schedule variant is `schedule_run_task`:

        ```rust
        use golem_rust::wasm_rpc::golem_rpc_0_2_x::types::Datetime;

        let remote_agent = BackgroundTaskAgentClient::get(background_job_id);

        remote_agent.schedule_run_task(
           DataTime{
             seconds: X,
             nanoseconds: Y
          }, "hello", 1234
        );
        ```

        Here the first parameter is a `Datetime` object, with seconds and nanoseconds fields representing the UNIX Epoch time when the method should be executed. The rest of the parameters are the same as for the original method.

     </Tabs.Tab>

</Tabs>

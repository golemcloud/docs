import { Callout, Tabs } from "nextra/components"

# Defining Golem Components

## Creating a project

Golem's **command line interface** provides a set of predefined, Golem-specific **templates** to choose from as a starting point.

<Tabs items={["TypeScript", "Rust"]}>
    <Tabs.Tab>
To get started from scratch, first create a new application using the `TS` template:

```shell copy
golem app new my-app ts
cd my-app
```
    </Tabs.Tab>

    <Tabs.Tab>
To get started from scratch, first create a new application using the `TS` template:

```shell copy
golem app new my-app rust
cd my-app
```
    </Tabs.Tab>

</Tabs>

An application can consist of multiple components. Add a new component by choosing from one of the available templates. To see the list of available templates, run:

```shell copy
golem component new
```

Then create a new component using the chosen template:

<Tabs items={["TypeScript", "Rust"]}>
    <Tabs.Tab>
```shell copy
golem component new ts my:component
```
    </Tabs.Tab>

    <Tabs.Tab>
```shell copy
golem component new rust my:component
```
    </Tabs.Tab>
</Tabs>

## Defining agents

Defining Golem agents is done using the Golem SDK, which is included in all the templates provided by `golem`.

<Tabs items={["TypeScript", "Rust"]}>
    <Tabs.Tab>
An agent is a TypeScript class that extends `BaseAgent` and has the `@agent` decorator:

```typescript
import {
    BaseAgent,
    agent,
    description,
    prompt
} from '@golemcloud/golem-ts-sdk';

@agent
class MyAgent extends BaseAgent {
    // ...
}
```
    </Tabs.Tab>
    <Tabs.Tab>
An agent is defined by a **trait** annotated as `#[agent_definition]` and a `struct` implementing it, annotated as `#[agent_implementation]`:

```rust
use golem_rust::{agent_definition, agent_implementation};

#[agent_definition]
pub trait CounterAgent {
  // ...
}

struct CounterAgentImpl {
    // ...
}

#[agent_implementation]
impl CounterAgent for CounterAgentImpl {
    // ...
}

```

    </Tabs.Tab>

</Tabs>

A component must define at least one agent, but can also define multiple ones.

### Agent constructors
Every agent must define a **constructor** with an arbitrary number of parameters. These parameters form the **agent identifier**. Every possible parameter value combination identifies a particular agent instance.

For example, an agent working on a particular user's particular request could be defined as:

<Tabs items={["TypeScript", "Rust"]}>
    <Tabs.Tab>
```typescript
@agent()
class RequestHandler extends BaseAgent {
    private readonly userId: string;
    private readonly requestId: string;

    constructor(userId: string, requestId: string) {
        super();
        this.userId = userId;
        this.requestId = requestId;
    }
}
```
    </Tabs.Tab>
    <Tabs.Tab>
```rust
#[agent_definition]
trait RequestHandler {
    pub fn new(userId: string, requestId: string) -> Self;
}
```
    </Tabs.Tab>
</Tabs>

An agent with a constructor like this can be identified by `request-handler("user-123", "request-456")`.

<Callout type="info">
    Note that the agent name is converted to _kebab-case_ (`request-handler`) when referred to in an agent identifier. This is due to some technical implementation details of the underlying Golem runtime. You can learn more about these mappings on the [name mapping page](/name-mapping).
</Callout>

### Agent methods

Every public method of an agent class is an **agent method**, which can be called by other remote agents, externally through Golem's invocation API, and can [also be mapped to HTTP APIs](/invoke/making-custom-apis).

Agent methods can (and should) be also annotated with the metadata such as `prompt` and `description`
- `prompt` should provide information for an external AI to understand what needs to be passed to the method as parameters
- `description` should be a human-readable description of what the method does

This metadata is stored in the Golem component and can be used when exposing the agents through MCP, for example.

The following example shows the use of how to attach these metadata to simple agent methods in different languages

<Tabs items={["TypeScript", "Rust"]}>
    <Tabs.Tab>
```typescript
type TaskDetails = // ...;
type RequestHandlerStatus = // ...;

@agent()
class RequestHandler extends BaseAgent {
    // ...

    @prompt("Enter new details about the task")
    @description("Adds some more details to the request handler about the task being performed. The result is an update of the current status.")
   async addDetails(details: TaskDetails): Promise<RequestHandlerStatus> {
       // ...
   }
}
```
    </Tabs.Tab>

    <Tabs.Tab>
```rust
use golem_rust::{Schema, agent_definition, prompt, description};

#[derive(Schema)]
pub struct TaskDetails {
    description: String,
    priority: u8,
}

#[derive(Schema)]
pub enum RequestHandlerStatus {
    Success(String),
    Failure(String),
}

#[agent_definition]
pub trait RequestHandler {
    async fn new(name: String) -> Self;

    #[prompt("Enter new details about the task")]
    #[description("Adds some more details to the request handler about the task being performed. The result is an update of the current status.")]
    async fn add_details(&self, task_details: TaskDetails) -> RequestHandlerStatus;
}
```
    </Tabs.Tab>

</Tabs>

Agent methods can be both sync or async.

### Supported data types
The SDK supports a large variety of data types to be used in agent constructors and agent methods, both in parameter and return type position. When a type is not supported, it will report an error at compile time.

<Tabs items={["TypeScript", "Rust"]}>
    <Tabs.Tab>
    In TypeScript most user-defined data type will work as expected. See the [page about data type mapping](/type-mapping) for more details.
    </Tabs.Tab>

    <Tabs.Tab>
    In Rust any data type that implements the `golem_rust::Schema` trait can be used as parameters and return types of agent metods and constructors. For user-defined types, use `#[derive(Schema)]` to derive the implementation automatically. See the [page about data type mapping](/type-mapping) for more details about the supported built-in types.
    </Tabs.Tab>
</Tabs>

Check the [page about data type mapping](/type-mapping) to learn how each type is mapped to **Rib** (when calling the agent methods from the API gateway or the REPL) and **JSON** (when using the invocation API).

### Agent mode - durable or ephemeral
By default every agent is **durable**. To define an **ephemeral agent**, override the agent mode in the agent definition:

<Tabs items={["TypeScript", "Rust"]}>
    <Tabs.Tab>
    ```typescript
    @agent({ mode: 'ephemeral' })
    class EphemeralAgent extends BaseAgent {
      // ...
    }
    ```
    </Tabs.Tab>

    <Tabs.Tab>
    ```rust
    #[agent_definition(ephemeral)]
    trait EphemeralAgent {
      // ...
    }  
    ```
    </Tabs.Tab>
</Tabs>

## Agent configuration

It is often required to pass _configuration values_ to agents when they are started.

In general Golem supports three different ways of doing this:

1. Defining a list of string arguments passed to the agent, available as **command line arguments**
2. Defining a list of key-value pairs passed to the agent, available as **environment variables**.
3. Defining dedicated configuration key-value pairs (experimental).

### Command line arguments and environment variables

<Tabs items={["TypeScript", "Rust"]}>
<Tabs.Tab>
Command line arguments and environment variables are accessible through the `node:process` module:

```typescript
import { argv, env } from "node:process";
```
</Tabs.Tab>


<Tabs.Tab>
Command line arguments and environment variables are accessible through the `std::env` module:
```rust
use std::env;
let agent_id = env::var("GOLEM_AGENT_ID").unwrap();
```
</Tabs.Tab>

</Tabs>

Environment variables can be specified when an agent is **explicitly created**, but there are some environment variables that are always set by Golem:

- `GOLEM_AGENT_ID` - the ID of the agent
- `GOLEM_AGENT_TYPE` - the agent type (first part of the agent ID)
- `GOLEM_COMPONENT_ID` - the ID of the agent's component
- `GOLEM_COMPONENT_VERSION` - the version of the component used for this agent

In addition to these, when using [Agent to Agent communication](/develop/rpc), agents created by remote calls **inherit the environment variables of the caller**.

This feature makes environment variables a good fit for passing configuration such as hostnames, ports, or access tokens to trees of agents.

#### Default environment variables
It is possible to define default environment values and config key-value pairs for a component using the **app manifest**. These values are automatically set for each agent created from the component, but can be overridden when creating the agent.

To set component level environment variables, use the `env` section of the `golem.yaml`:

```yaml
components:
    my:component:
        env:
            MY_ENV_VAR: "some value"
            ANOTHER_ENV_VAR: "another value"
```

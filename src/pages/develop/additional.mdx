import { Callout, Tabs } from "nextra/components"

# Additional Runtime APIs

### Generate an idempotency key

Golem provides a function to generate an idempotency key (a UUID) which can be passed to external systems to ensure that the same request is not processed multiple times.

It is guaranteed that this idempotency key will always be the same (per occurrence) even if the agent is restarted due to a crash.

To generate an idempotency key:

<Tabs items={["TypeScript", "Rust"]}>
    <Tabs.Tab>
```typescript
import { generateIdempotencyKey, Uuid } from "golem:api/host@1.1.7";

const key: Uuid = generateIdempotencyKey();
```
    </Tabs.Tab>
    <Tabs.Tab>
```rust
use golem_rust::{Uuid, generate_idempotency_key};
let key: Uuid = generate_idempotency_key();
```
    </Tabs.Tab>
</Tabs>

### Get agent metadata

It is possible to query **metadata** for Golem agents. This metadata is defined by the `AgentMetadata` interface:

<Tabs items={["TypeScript", "Rust"]}>
    <Tabs.Tab>
    ```typescript
    /**
     * Metadata about an agent
     */
    export type AgentMetadata = {
      /** The agent ID, consists of the component ID, agent type and agent parameters */
      agentId: AgentId;
      /** Command line arguments seen by the agent */
      args: string[];
      /** Environment variables seen by the agent */
      env: [string, string][];
      /** Configuration variables seen by the agent */
      configVars: [string, string][];
      /** The current agent status */
      status: AgentStatus;
      /** The component version the agent is running with */
      componentVersion: bigint;
      /** The agent's current retry count */
      retryCount: bigint;
    };
    ```

    There are two exported functions to query agent metadata:

    - `getSelfMetadata()` returns the metadata for the current agent
    - `getAgentMetadata(agentId: AgentId)` returns the metadata for a specific agent given by its `AgentId`

    </Tabs.Tab>
    <Tabs.Tab>
    ```rust
    /**
     * Metadata about an agent
     */
     pub struct AgentMetadata {
       // The agent ID, consists of the component ID, agent type and agent parameters
       pub agent_id: AgentId,
       // Command line arguments seen by the agent
       pub args: Vec<String>,
       // Environment variables seen by the agent
       pub env: Vec::<(String, String,)>,
       // Configuration variables seen by the agent
       pub config_vars: Vec::<(String, String,)>,
       // The current agent status
       pub status: AgentStatus,
       // The component version the agent is running with
       pub component_version: u64,
       // The agent\'s current retry count
       pub retry_count: u64,
     }
    ```

    There are two exported functions to query agent metadata:

    - `get_self_metadata()` returns the metadata for the current agent
    - `get_agent_metadata(agent_id: &AgentId)` returns the metadata for a specific agent given by its `AgentId`

    </Tabs.Tab>

</Tabs>

### Enumerate agents

Agent enumeration is a feature of Golem available both through the public HTTP API and using the SDK.

<Callout type="warning">
    Enumerating agents of a component is a slow operation and should not be used as part of the application logic.
</Callout>

The following example demonstrates how to use the agent enumeration API:

<Tabs items={["TypeScript", "Rust"]}>
    <Tabs.Tab>
```typescript
import {
  ComponentId,
  GetAgents,
  AgentAnyFilter,
  AgentMetadata,
  AgentStatusFilter,
} from "golem:api/host@1.1.0"

const filter: AgentAnyFilter = {
  filters: [
    {
      filters: [
        {
          tag: "status",
          val: {
            comparator: "equal",
            value: "idle",
          } satisfies AgentStatusFilter,
        },
      ],
    },
  ],
}

const componentId: ComponentId = {
  /* ... */
}
const agents: AgentMetadata[] = []
const getter = new GetAgents(componentId, filter, true)

let batch: AgentMetadata[] | undefined
while ((batch = getter.getNext()) !== undefined) {
  agents.push(...batch)
}
```
    </Tabs.Tab>

   <Tabs.Tab>
```rust
use golem_rust::{
    bindings::golem::api::host::{AgentAnyFilter, GetAgents},
    wasm_rpc::{ComponentId, Uuid},
    Uuid
};

let component_id: ComponentId = /** */

let filter = AgentAnyFilter {
   filters: vec![AgentAllFilter {
     filters: vec![AgentPropertyFilter::Status(AgentStatusFilter {
       comparator: FilterComparator::Equal,
       value: AgentStatus::Idle,
     })],
   }],
};

let getter = GetAgents::new(component_id, Some(&filter), true);

let mut batch = getter.get_next();

let mut agents: Vec<AgentMetadata> = vec![];

while batch.is_some() {
  agents.extend(batch.unwrap());
  batch = getter.get_next();
}

```
    </Tabs.Tab>
</Tabs>

The third parameter of the `GetAgents` constructor enables `precise` mode. In this mode, Golem will calculate the latest metadata for each returned agent; otherwise, it uses only the last cached values.

### Update an agent

<Tabs items={["TypeScript", "Rust"]}>
    <Tabs.Tab>
To trigger an update for a given agent from one component version to another, use the `updateAgent` function:

```typescript
import { updateAgent, AgentId, ComponentVersion } from "golem:api/host@0.2.0"

const agentId: AgentId = {
  /* ... */
}

const targetVersion: ComponentVersion = 1n

updateAgent(agentId, targetVersion, "automatic")
```
    </Tabs.Tab>

    <Tabs.Tab>
To trigger an update for a given agent from one component version to another, use the `update_agent` function:

```rust
use golem_rust::bindings::golem::api::host::{update_agent, AgentId, ComponentVersion, UpdateMode};

let target_component_version: ComponentVersion = 1;

let agent_id: AgentId = todo!("...");

update_agent(&agent_id, target_component_version, UpdateMode::Automatic);
```
    </Tabs.Tab>
</Tabs>

To learn more about updating agents, see the Agent Update section of the [agents page](/concepts/agents).

### Oplog search and query
The `oplog` interface in `golem:api` provides functions to search and query the agent's persisted oplog.

The interface defines a big `variant` data type called `oplog-entry`, and two **resources** for querying an agent's oplog.

- the `get-oplog` resource enumerates through **all entries** of the oplog
- the `search-oplog` resource accepts a **search expression** and only returns the matching entries

Both resources, once constructed, provide a `get-next` function that returns a chunk of oplog entries. Repeatedly calling this function goes through the whole data set, and eventually returns `none`.

### Durability
The `golem:durability` package contains an API that libraries can leverage to provide a custom durability implementation for their own API. This is the same interface that Golem uses under the hood to make the WASI interfaces durable. Golem applications are not supposed to use this package directly.

#### Types

<Tabs items={["TypeScript", "Rust"]}>
    <Tabs.Tab>
    The durability API can be imported from the `golem:durability/durability@1.2.1` module.

The `DurableFunctionType` type categorizes a durable function in the following way:

```typescript
export type DurableFunctionType =
  {
    tag: 'read-local'
  } |
  {
    tag: 'write-local'
  } |
  {
    tag: 'read-remote'
  } |
  {
    tag: 'write-remote'
  } |
  {
    tag: 'write-remote-batched'
    val: OplogIndex | undefined
  } |
  {
    tag: 'write-remote-transaction'
    val: OplogIndex | undefined
  };
```

- `read-local` indicates that the side effect reads from the agent's local state (for example local file system, random generator, etc.)
- `write-local` indicates that the side effect writes to the agent's local state (for example local file system)
- `read-remote` indicates that the side effect reads from external state (for example a key-value store)
- `write-remote` indicates that the side effect manipulates external state (for example an RPC call)
- `write-remote-batched` indicates that the side effect manipulates external state through multiple invoked functions (for example an HTTP request where reading the response involves multiple host function calls)
- `write-remote-transaction` indicates that the side effect manipulates external state through multiple invoked functions, and all of them are part of a single transaction (for example a database transaction)

The `DurableExecutionState` type provides information about the current execution state, and can be queried using the `currentDurableExecutionState` function:

```typescript
/**
 * Gets the current durable execution state
 */
export function currentDurableExecutionState(): DurableExecutionState;

export type DurableExecutionState = {
  isLive: boolean;
  persistenceLevel: PersistenceLevel;
};

/**
 * Configurable persistence level for agents
 */
export type PersistenceLevel = {
    tag: 'persist-nothing'
  } |
  {
    tag: 'persist-remote-side-effects'
  } |
  {
    tag: 'smart'
  };
```

Here the `isLive` field indicates whether the executor is currently _replaying_ an agent's previously persisted state or side effects should be executed. The `persistenceLevel` is a user-configurable setting that can turn off persistence for certain sections of the code.

The `PersistedDurableFunctionInvocation` is a record holding all the information about one persisted durable function. This should be used during _replay_ to simulate the side effect instead of actually running it.

```typescript
export type PersistedDurableFunctionInvocation = {
  timestamp: Datetime;
  functionName: string;
  response: ValueAndType;
  functionType: DurableFunctionType;
  entryVersion: OplogEntryVersion;
};
```

</Tabs.Tab>

    <Tabs.Tab>
    The durability API can be imported from the `golem_rust::bindings::golem::durability` module.

The `DurableFunctionType` type categorizes a durable function in the following way:

```rust
pub type DurableFunctionType = WrappedFunctionType;

pub enum WrappedFunctionType {
  ReadLocal,
  WriteLocal,
  ReadRemote,
  WriteRemote,
  WriteRemoteBatched(Option<OplogIndex>),
  WriteRemoteTransaction(Option<OplogIndex>),
}
```

- `ReadLocal` indicates that the side effect reads from the agent's local state (for example local file system, random generator, etc.)
- `WriteLocal` indicates that the side effect writes to the agent's local state (for example local file system)
- `ReadRemote` indicates that the side effect reads from external state (for example a key-value store)
- `WriteRemote` indicates that the side effect manipulates external state (for example an RPC call)
- `WriteRemoteBatched` indicates that the side effect manipulates external state through multiple invoked functions (for example an HTTP request where reading the response involves multiple host function calls)
- `WriteRemoteTransaction` indicates that the side effect manipulates external state through multiple invoked functions, and all of them are part of a single transaction (for example a database transaction)

The `DurableExecutionState` type provides information about the current execution state, and can be queried using the `current_durable_execution_state` function:

```rust
/**
 * Gets the current durable execution state
 */
fn current_durable_execution_state(): DurableExecutionState;

pub struct DurableExecutionState {
  // If true, the executor is in live mode, side-effects should be performed and persisted
  // If false, the executor is in replay mode, side-effects should be replayed from the persisted data
  pub is_live: bool,
  // The currently active persistence level
  pub persistence_level: PersistenceLevel,
}

/**
 * Configurable persistence level for agents
 */
pub enum PersistenceLevel {
  PersistNothing,
  PersistRemoteSideEffects,
  Smart
}


pub struct PersistedDurableFunctionInvocation {
  // The timestamp of the invocation.
  pub timestamp: Datetime,
  // The invoked function\'s unique name
  pub function_name: _rt::String,
  // Arbitrary structured value (and type) describing the invocation\'s result
  pub response: ValueAndType,
  // Type of the durable function invocation
  pub function_type: DurableFunctionType,
  // Oplog entry version
  pub entry_version: OplogEntryVersion,
}

```

</Tabs.Tab>
</Tabs>

#### Functions

The durability API consists of a couple of low-level functions that must be called in a correct way to make it work.

The logic to be implemented is the following, in pseudocode:



<Tabs items={["TypeScript", "Rust"]}>
    <Tabs.Tab>

```typescript
observeFunctionCall("interface", "function")
state = currentDurableExecutionState()
if (state.isLive) {
  result = performSideEffect(input)
  persistTypedDurableFunctionInvocation("function", encode(input), encode(result), durableFunctionType)
} else {
  // Execute the side effect
  persisted = readPersistedDurableFunctionInvocation()
  result = decode(persisted.response)
}
```

</Tabs.Tab>

<Tabs.Tab>
    ```rust
  use golem_rust::Schema

  #[derive(Schema)]
  pub struct FunctionResult {
    value: String
  }

  observe_function_call("iface", "function");

  let state = current_durable_execution_state();

  if (state.is_live) {
      let input = "foo".to_string();
      let result: FunctionResult = perform_side_effect("foo".to_string());

      // the input and output must be encoded to ValueAndType
      // `into_value_and_type` will be automatically available for all types deriving Schema
      persist_durable_function_invocation("function",  &input.into_value_and_type() , &result.into_value_and_type(), DurableFunctionType::ReadRemote);
  } else {
     let persisted =  read_persisted_durable_function_invocation();

     // the result must be can be decoded from ValueAndType, as long as the type derives Schema
     let result: FunctionResult =  FunctionResult::from_value_and_type(persisted.response).expect("failed to decode");
  }

    ```

  </Tabs.Tab>
</Tabs>


The `input` and `result` values must be encoded into `ValueAndType`, the dynamic value representation from the `golem:rpc` package.

In cases when a durable function's execution interleaves with other calls, the `beginDurableFunction` and `endDurableFunction` calls can be used to mark the beginning and end of the operation.


### Invocation context

Golem associates an **invocation context** with each invocation, which contains various information depending on how the exported function was called. This context gets inherited when making further invocations via agent-to-agent communication, and it is also possible to define custom **spans** and associate custom **attributes** to it.

The spans are not automatically sent to any tracing system but they can be reconstructed from the oplog, for example using **oplog processor plugins**, to provide real-time tracing information.

<Tabs items={["TypeScript", "Rust"]}>
    <Tabs.Tab>
To get the current invocation context, use the `currentContext` host function, imported from `golem:api/context@1.1.7`:

```typescript
/**
 * Invocation context support
 */
declare module 'golem:api/context@1.1.7' {
  /**
   * Gets the current invocation context
   * The function call captures the current context; if new spans are started, the returned `invocation-context` instance will not
   * reflect that.
   */
  export function currentContext(): InvocationContext;
}
```

The `InvocationContext` itself is a **class** with various methods for querying attributes of the invocation context:

| method | description |
| ------ | ----------- |
| `traceId` | Returns the trace ID associated with the context, coming from either an external trace header or generated at the edge of Golem |
| `spanId` | Returns the span ID associated with the context |
| `parent` | Returns the parent invocation context, if any |
| `getAttribute` | Gets an attribute from the context by key |
| `getAttributes` | Gets all attributes from the context |
| `getAttributeChain` | Gets all values of a given attribute from the current and parent contexts |
| `getAttributeChains` | Get all attributes and their previous values |
| `traceContextHeaders` | Gets the W3C Trace Context headers associated with the current invocation context |

Custom attributes can only be set on **custom spans**. First start a new span using `startSpan`

```typescript
/**
 * Starts a new `span` with the given name, as a child of the current invocation context
 */
export function startSpan(name: string): Span;
```

and then use the `Span` class's methods:

| method | description |
| ------ | ----------- |
| `startedAt` | Returns the timestamp when the span was started |
| `setAttribute` | Sets an attribute on the span |
| `setAttributes` | Sets multiple attributes on the span |
| `finish` | Ends the current span |

If `finish` is not explicitly called on the span, it is going to be finished when the garbage collector deletes the span object.

</Tabs.Tab>

    <Tabs.Tab>
To get the current invocation context, use the `current_context` host function, imported from `golem_rust::bindings::golem::api::context`:

```rust
/**
 * Invocation context support
 */
fn current_context(): InvocationContext;
```

The `InvocationContext` itself is a **class** with various methods for querying attributes of the invocation context:

| method | description |
| ------ | ----------- |
| `trace_id` | Returns the trace ID associated with the context, coming from either an external trace header or generated at the edge of Golem |
| `span_id` | Returns the span ID associated with the context |
| `parent` | Returns the parent invocation context, if any |
| `get_attribute` | Gets an attribute from the context by key |
| `get_attributes` | Gets all attributes from the context |
| `get_attribute_chain` | Gets all values of a given attribute from the current and parent contexts |
| `get_attribute_chains` | Get all attributes and their previous values |
| `trace_context_headers` | Gets the W3C Trace Context headers associated with the current invocation context |

Custom attributes can only be set on **custom spans**. First start a new span using `start_span`

```rust
/**
 * Starts a new `span` with the given name, as a child of the current invocation context
 */
pub fn start_span(name: &str) -> Span
```

and then use the `Span` class's methods:

| method | description |
| ------ | ----------- |
| `started_at` | Returns the timestamp when the span was started |
| `set_attribute` | Sets an attribute on the span |
| `set_attributes` | Sets multiple attributes on the span |
| `finish` | Ends the current span |

If `finish` is not explicitly called on the span, it is going to be finished when the garbage collector deletes the span object.

</Tabs.Tab>

</Tabs>

The custom spans are pushed onto the invocation context stack, so whenever an RPC call or HTTP call is made, their parent span(s) will include the user-defined custom spans as well as the rest of the invocation context.

### The WASI Key-Value store interface

Although Golem agents can store their state completely in their own memory, it is possible to use the `wasi:keyvalue` interface to store key-value pairs in a Golem managed key value storage.

This can be useful if state needs to be shared between different agents or if the size of this state is too large to be stored in memory. The keys are accessible for every agent of an _application_ - no matter which component they are defined in, or which agent type they belong to.

<Tabs items={["TypeScript", "Rust"]}>
    <Tabs.Tab>
        There are two primary modules for using the key-value store:
        - `wasi:keyvalue/eventual@0.1.0` defines an API for an eventually consistent key-value store
        - `wasi:keyvalue/eventual-batch@0.1.0` defines an API with batch operations working on multiple keys

        The primary interface to work with the key-value pairs consists of the four basic operations:

        ```typescript
        /**
        * Get the value associated with the key in the bucket.
        * The value is returned as an option. If the key-value pair exists in the
        * bucket, it returns `Ok(value)`. If the key does not exist in the
        * bucket, it returns `Ok(none)`.
        * If any other error occurs, it returns an `Err(error)`.
        * @throws Error
        */
        export function get(bucket: Bucket, key: Key): IncomingValue | undefined;
        /**
        * Set the value associated with the key in the bucket. If the key already
        * exists in the bucket, it overwrites the value.
        * If the key does not exist in the bucket, it creates a new key-value pair.
        * If any other error occurs, it returns an `Err(error)`.
        * @throws Error
        */
        export function set(bucket: Bucket, key: Key, outgoingValue: OutgoingValue): void;
        /**
        * Delete the key-value pair associated with the key in the bucket.
        * If the key does not exist in the bucket, it does nothing.
        * If any other error occurs, it returns an `Err(error)`.
        * @throws Error
        */
        export function delete_(bucket: Bucket, key: Key): void;
        /**
        * Check if the key exists in the bucket.
        * If the key exists in the bucket, it returns `Ok(true)`. If the key does
        * not exist in the bucket, it returns `Ok(false)`.
        * If any other error occurs, it returns an `Err(error)`.
        * @throws Error
        */
        export function exists(bucket: Bucket, key: Key): boolean;
        ```

        The batch API defines similar functions such as `getMany` and `setMany`, but working on multiple keys at once.

        The `IncomingValue` and `OutgoingValue` types are defined as follows:

        ```typescript
        export class OutgoingValue {
            static newOutgoingValue(): OutgoingValue;
            /**
             * Writes the value to the output-stream asynchronously.
             * If any other error occurs, it returns an `Err(error)`.
             * @throws Error
             */
            outgoingValueWriteBodyAsync(): OutgoingValueBodyAsync;
            /**
             * Writes the value to the output-stream synchronously.
             * If any other error occurs, it returns an `Err(error)`.
             * @throws Error
             */
            outgoingValueWriteBodySync(value: OutgoingValueBodySync): void;
        }

        export class IncomingValue {
            /**
             * Consumes the value synchronously and returns the value as a list of bytes.
             * If any other error occurs, it returns an `Err(error)`.
             * @throws Error
             */
            incomingValueConsumeSync(): IncomingValueSyncBody;
            /**
             * Consumes the value asynchronously and returns the value as an `input-stream`.
             * If any other error occurs, it returns an `Err(error)`.
             * @throws Error
             */
            incomingValueConsumeAsync(): IncomingValueAsyncBody;
            /**
             * The size of the value in bytes.
             * If the size is unknown or unavailable, this function returns an `Err(error)`.
             * @throws Error
             */
            incomingValueSize(): bigint;
        }

        export type OutgoingValueBodyAsync = OutputStream;
        export type OutgoingValueBodySync = Uint8Array;
        export type IncomingValueAsyncBody = InputStream;
        export type IncomingValueSyncBody = Uint8Array;
        ```

        The streaming variants of setting and consuming the values may be used by the underlying implementation to directly
        stream the data to the key-value store. For small values, the sync variants are more convenient, directly taking and returning
        a `Uint8Array`.
    </Tabs.Tab>

       <Tabs.Tab>
            There are two primary modules for using the key-value store:
            - `golem_rust::bindings::wasi::keyvalue::eventual` defines an API for an eventually consistent key-value store
            - `golem_rust::bindings::wasi::keyvalue::eventual_batch` defines an API with batch operations working on multiple keys

            The primary interface to work with the key-value pairs consists of the four basic operations:

            ```rust
            /**
            * Get the value associated with the key in the bucket.
            * The value is returned as an option. If the key-value pair exists in the
            * bucket, it returns `Ok(value)`. If the key does not exist in the
            * bucket, it returns `Ok(none)`.
            * If any other error occurs, it returns an `Err(error)`.
            * @throws Error
            */
            pub fn get(bucket: &Bucket, key: &str) -> Result<Option<IncomingValue>, Error>
            /**
            * Set the value associated with the key in the bucket. If the key already
            * exists in the bucket, it overwrites the value.
            * If the key does not exist in the bucket, it creates a new key-value pair.
            * If any other error occurs, it returns an `Err(error)`.
            * @throws Error
            */
            pub fn set(bucket: &Bucket, key: &str, outgoing_value: &OutgoingValue) -> Result<(), Error>
            /**
            * Delete the key-value pair associated with the key in the bucket.
            * If the key does not exist in the bucket, it does nothing.
            * If any other error occurs, it returns an `Err(error)`.
            * @throws Error
            */
            pub fn delete(bucket: &Bucket, key: &str) -> Result<(), Error>
            /**
            * Check if the key exists in the bucket.
            * If the key exists in the bucket, it returns `Ok(true)`. If the key does
            * not exist in the bucket, it returns `Ok(false)`.
            * If any other error occurs, it returns an `Err(error)`.
            * @throws Error
            */
            pub fn exists(bucket: &Bucket, key: &str) -> Result<bool, Error>
            ```

            The batch API defines similar functions such as `get_many` and `set_many`, but working on multiple keys at once.

            The `IncomingValue` is  basically a handle to a WASI resource that contains the value.
            To actually extract the bytes, it defines two consume methods.

            The `OutgoingValue` is a handle to a WASI resource that can be used to write the value.
            It defines methods to write the bytes into the resource.

            Similarly,

            ```rust
            impl OutgoingValue {
                pub fn new_outgoing_value() -> OutgoingValue {
                /**
                 * Writes the value to the output-stream asynchronously.
                 * If any other error occurs, it returns an `Err(error)`.
                 * @throws Error
                 */
                pub fn outgoing_value_write_body_async(&self) -> Result<OutgoingValueBodyAsync, Error>
                /**
                 * Writes the value to the output-stream synchronously.
                 * If any other error occurs, it returns an `Err(error)`.
                 * @throws Error
                 */
                pub fn outgoing_value_write_body_sync(&self, value: &[u8]) -> Result<(), Error>
            }


            impl IncomingValue {
                /**
                 * Consumes the value synchronously and returns the value as a list of bytes.
                 * If any other error occurs, it returns an `Err(error)`.
                 * @throws Error
                 */
                pub fn incoming_value_consume_sync(&self) -> Result<IncomingValueSyncBody, Error>
                /**
                 * Consumes the value asynchronously and returns the value as an `input-stream`.
                 * If any other error occurs, it returns an `Err(error)`.
                 * @throws Error
                 */
                pub fn incoming_value_consume_async(&self) -> Result<IncomingValueAsyncBody, Error>
                /**
                 * The size of the value in bytes.
                 * If the size is unknown or unavailable, this function returns an `Err(error)`.
                 * @throws Error
                 */
                pub fn size(&self) -> u64
            }

            pub type OutgoingValueBodyAsync = OutputStream;
            pub type OutgoingValueBodySync = Vec<u8>;
            pub type IncomingValueAsyncBody = InputStream;
            pub type IncomingValueSyncBody = Vec<u8>;
            ```

            The streaming variants of setting and consuming the values may be used by the underlying implementation to directly
            stream the data to the key-value store. For small values, the sync variants are more convenient, directly taking and returning
            a `Vec<u8>`.
        </Tabs.Tab>
</Tabs>

### The WASI Blob Store interface

The `wasi:blobstore` interface provides a way to store and retrieve large binary data. This can be useful for storing large files or other binary data that is too large to be stored in the agent's memory. The blobs are accessible for every agent of an _application_ - no matter which component they are defined in, or which agent type they belong to.

<Tabs items={["TypeScript", "Rust"]}>
    <Tabs.Tab>
        The Blob Store API organizes blobs identified by _object names_ into **containers**. The `wasi:blobstore/blobstore` module exports functions to create, get and delete these containers by name:

        ```typescript
        declare module 'wasi:blobstore/blobstore' {
            /**
             * creates a new empty container
             * @throws Error
             */
            export function createContainer(name: ContainerName): Container;
            /**
             * retrieves a container by name
             * @throws Error
             */
            export function getContainer(name: ContainerName): Container;
            /**
             * deletes a container and all objects within it
             * @throws Error
             */
            export function deleteContainer(name: ContainerName): void;
            /**
             * returns true if the container exists
             * @throws Error
             */
            export function containerExists(name: ContainerName): boolean;
            /**
             * copies (duplicates) an object, to the same or a different container.
             * returns an error if the target container does not exist.
             * overwrites destination object if it already existed.
             * @throws Error
             */
            export function copyObject(src: ObjectId, dest: ObjectId): void;
            /**
             * moves or renames an object, to the same or a different container
             * returns an error if the destination container does not exist.
             * overwrites destination object if it already existed.
             * @throws Error
             */
            export function moveObject(src: ObjectId, dest: ObjectId): void;

            // ...
        }
        ```

        A `Container` is a class providing read-write access for the blobs in it:

        ```typescript
        export class Container {
            /**
             * returns container name
             * @throws Error
             */
            name(): string;
            /**
             * returns container metadata
             * @throws Error
             */
            info(): ContainerMetadata;
            /**
             * retrieves an object or portion of an object, as a resource.
             * Start and end offsets are inclusive.
             * Once a data-blob resource has been created, the underlying bytes are held by the blobstore service for the lifetime
             * of the data-blob resource, even if the object they came from is later deleted.
             * @throws Error
             */
            getData(name: ObjectName, start: bigint, end: bigint): IncomingValue;
            /**
             * creates or replaces an object with the data blob.
             * @throws Error
             */
            writeData(name: ObjectName, data: OutgoingValue): void;
            /**
             * returns list of objects in the container. Order is undefined.
             * @throws Error
             */
            listObjects(): StreamObjectNames;
            /**
             * deletes object.
             * does not return error if object did not exist.
             * @throws Error
             */
            deleteObject(name: ObjectName): void;
            /**
             * deletes multiple objects in the container
             * @throws Error
             */
            deleteObjects(names: ObjectName[]): void;
            /**
             * returns true if the object exists in this container
             * @throws Error
             */
            hasObject(name: ObjectName): boolean;
            /**
             * returns metadata for the object
             * @throws Error
             */
            objectInfo(name: ObjectName): ObjectMetadata;
            /**
             * removes all objects within the container, leaving the container empty.
             * @throws Error
             */
            clear(): void;
        }
        ```

        The `IncomingValue` and `OutgoingValue` classes are, similar to the **key-value store interface**, providing two ways to work with the blobs: synchronously using `UInt8Array`s or using the `InputStream` and `OutputStream` interfaces for saving/loading the data by chunks.
    </Tabs.Tab>

    <Tabs.Tab>
        The Blob Store API organizes blobs identified by _object names_ into **containers**. The `golem_rust::bindings::wasi::blobstore::blobstore` has functions to create, get and delete these containers by name:

        ```rust
           /**
            * creates a new empty container
            */
           pub fn create_container(name: &str) -> Result<Container, Error>
           /**
            * retrieves a container by name
            */
           pub fn get_container(name: &str) -> Result<Container, Error>
           /**
            * deletes a container and all objects within it
            */
           pub fn delete_container(name: &str) -> Result<(), Error>
           /**
            * returns true if the container exists
            */
           pub fn container_exists(name: &str) -> Result<bool, Error>
           /**
            * copies (duplicates) an object, to the same or a different container.
            * returns an error if the target container does not exist.
            * overwrites destination object if it already existed.
            */
           pub fn copy_object(src: &ObjectId, dest: &ObjectId) -> Result<(), Error>
           /**
            * moves or renames an object, to the same or a different container
            * returns an error if the destination container does not exist.
            * overwrites destination object if it already existed.
            */
           pub fn move_object(src: &ObjectId, dest: &ObjectId) -> Result<(), Error>
        ```

        A `Container` in  is a class providing read-write access for the blobs in it:

        ```rust
        impl Container {
            /**
             * returns container name
             */
            pub fn name(&self) -> Result<String, Error>
            /**
             * returns container metadata
             */
            pub fn info(&self) -> Result<ContainerMetadata, Error>
            /**
             * retrieves an object or portion of an object, as a resource.
             * Start and end offsets are inclusive.
             * Once a data-blob resource has been created, the underlying bytes are held by the blobstore service for the lifetime
             * of the data-blob resource, even if the object they came from is later deleted.
             */
            pub fn get_data(&self, name: &str, start: u64, end: u64) -> Result<IncomingValue, Error>
            /**
             * creates or replaces an object with the data blob.
             */
            pub fn write_data(&self, name: &str, data: &OutgoingValue) -> Result<(), Error>
            /**
             * returns list of objects in the container. Order is undefined.
             */
            pub fn list_objects(&self) -> Result<StreamObjectNames, Error>
            /**
             * deletes object.
             * does not return error if object did not exist.
             */
            pub fn delete_object(&self, name: &str) -> Result<(), Error>
            /**
             * deletes multiple objects in the container
             */
            pub fn delete_objects(&self, names: &[ObjectName]) -> Result<(), Error>
            /**
             * returns true if the object exists in this container
             */
            pub fn has_object(&self, name: &str) -> Result<bool, Error>
            /**
             * returns metadata for the object
             */
            pub fn object_info(&self, name: &str) -> Result<ObjectMetadata, Error>
            /**
             * removes all objects within the container, leaving the container empty.
             */
            pub fn clear(&self) -> Result<(), Error>
        }
        ```

        The `IncomingValue` and `OutgoingValue` classes are, similar to the **key-value store interface**, providing two ways to work with the blobs: synchronously using `UInt8Array`s or using the `InputStream` and `OutputStream` interfaces for saving/loading the data by chunks.
    </Tabs.Tab>
</Tabs>

import { Tabs } from "nextra/components"

# High level transactions

On top of the [durability controls](/develop/durability) and [retry controls](/develop/retries), the SDKs also provide high level functions for defining transactions supporting **compensation actions** in case of getting reverted.

Although Golem's automatic retry policies and low-level atomic regions provide a lot of power automatically, many times a set of external operations such as HTTP requests needs to be executed **transactionally**; if one of the operations fails, the whole transaction need to be rolled back by executing some compensation actions.

The SDK provides support for two different types of transactions:

- **fallible transactions** are only dealing with domain errors
- **infallible transactions** must always succeed, and Golem applies its active retry policy to it

### Fallible transactions

Many times external operations (such as HTTP calls to remote hosts) need to be executed transactionally. If some operations failed, the transaction needs to be rolled back; compensation actions need to undo whatever the already successfully performed operations did.

A **fallible transaction** only deals with domain errors. Within the transaction every operation that succeeds gets recorded. If an operation fails, all the recorded operations get compensated in reverse order before the transaction block returns with a failure.

<Tabs items={["TypeScript", "Rust"]} storageKey="nextra-tabs-Rust|TypeScript">
    <Tabs.Tab>
        A fallible transaction can be executed using the `fallibleTransaction` function, by passing a closure that can
        execute operations on the open transaction (see below).
    </Tabs.Tab>
   <Tabs.Tab>
        A fallible transaction can be executed using the `fallible_transaction` function in `golem_rust`, by passing a closure that can
        execute operations on the open transaction (see below).
    </Tabs.Tab>
</Tabs>

### Infallible transactions

An infallible transaction must always succeed; in case of a failure or interruption, it gets retried. If there is a domain error, the compensation actions are executed before the retry.

<Tabs items={["TypeScript", "Rust"]} storageKey="nextra-tabs-Rust|TypeScript">
    <Tabs.Tab>
        An infallible transaction can be executed using the `infallibleTransaction` function, by passing a closure that
        can execute **operations** on the open transaction (see below).
    </Tabs.Tab>
      <Tabs.Tab>
            An infallible transaction can be executed using the `infallible_transaction` function in `golem_rust`, by passing a closure that
            can execute **operations** on the open transaction (see below).
      </Tabs.Tab>
</Tabs>

### Operations

Both transaction types require the definition of **operations**.

It is defined with the following interface:

<Tabs items={["TypeScript", "Rust"]} storageKey="nextra-tabs-Rust|TypeScript">
    <Tabs.Tab>
        ```typescript
        /**
        * Represents an atomic operation of the transaction which has a rollback action.
        *
        * Implement this interface and use it within a `transaction` block.
        * Operations can also be constructed from closures using `operation`.
        */
        export interface Operation<In, Out, Err> {
        /**
         * The action to execute.
         * @param input - The input to the operation.
         * @returns The result of the operation.
         */
        execute(input: In): Result<Out, Err>
        /**
         * Compensation to perform in case of failure.
         * Compensations should not throw errors.
         * @param input - The input to the operation.
         * @param result - The result of the operation.
         * @returns The result of the compensation.
         */
        compensate(input: In, result: Out): Result<void, Err>
    }
        ```

        There are two ways to define an operation:

        1. Implement the `Operation` interface manually
        2. Use the `operation` function to create an operation from a pair of closures

        ```typescript
        export declare function operation<In, Out, Err>(
            execute: (input: In) => Result<Out, Err>,
            compensate: (input: In, result: Out) => Result<void, Err>
        ): Operation<In, Out, Err>
        ```

    </Tabs.Tab>

    <Tabs.Tab>

      ```rust

      /// Represents an atomic operation of the transaction which has a rollback action.
      ///
      /// Implement this trait and use it within a `transaction` block.
      /// Operations can also be constructed from closures using `operation`.
      pub trait Operation: Clone {
          type In: Clone;
          type Out: Clone;
          type Err: Clone;

          /// Executes the operation which may fail with a domain error
          fn execute(&self, input: Self::In) -> Result<Self::Out, Self::Err>;

          /// Executes a compensation action for the operation.
          fn compensate(&self, input: Self::In, result: Self::Out) -> Result<(), Self::Err>;
      }


      ```

        There are two ways to define an operation:

        1. Implement the `Operation` interface manually
        2. Use the `operation` function to create an operation from a pair of closures

        ```rust
     /// Constructs an `Operation` from two closures: one for executing the operation,
     /// and one for rolling it back. The rollback operation always sees the input and
     /// the output of the operation.
     ///
     /// This operation can run the compensation in both fallible and infallible transactions.
     pub fn operation<In: Clone, Out: Clone, Err: Clone>(
         execute_fn: impl Fn(In) -> Result<Out, Err> + 'static,
         compensate_fn: impl Fn(In, Out) -> Result<(), Err> + 'static,
     ) -> impl Operation<In = In, Out = Out, Err = Err> {
         FnOperation {
             execute_fn: Rc::new(execute_fn),
             compensate_fn: Rc::new(compensate_fn),
         }
     }
        ```

    </Tabs.Tab>

</Tabs>

### Executing operations

The defined operations can be executed in _fallible_ or _infallible_ mode:

<Tabs items={["TypeScript", "Rust"]} storageKey="nextra-tabs-Rust|TypeScript">
    <Tabs.Tab>
    ```typescript
    import { fallibleTransaction, infallibleTransaction, operation, Result } from "@golemcloud/golem-ts-sdk"

    // example operation with compensation
    const op = operation(
      (idx: number) => {
        // the operation / side effect
        return Result.ok("id-" + idx)
      },
      (id, idx) => {
        // compensation
        console.log(`reverting ${id}, ${idx}`)
        return Result.unit()
      }
    )

    // with fallibleTransaction errors have to be handled and propagated using the Result type
    const resultFallible = fallibleTransaction(tx => {
      return tx
        .execute(op, 1)
        .flatMap(firstId => tx.execute(op, 2).map(secondId => [firstId, secondId]))
    })

    // with infallibleTransaction no explicit error handling is needed, as it is handled by Golem retries
    const resultInfallible = infallibleTransaction(tx => {
      const firstId = tx.execute(op, 1)
      const secondId = tx.execute(op, 1)
      return [firstId, secondId]
    })
    ```
    </Tabs.Tab>
    <Tabs.Tab>
    ```rust
  use golem_rust::{fallible_transaction, infallible_transaction};

  let op = operation(
    |i: i32| Ok(format!("id-{}", i)),
    |id, idx| {
      println!("reverting {}, {}", id, idx);
      Ok(())
    },
  );

  let result_fallible = fallible_transaction(|tx| {
      tx.execute(op, 1)
          .and_then(|first_id| tx.execute(op, 2).map(|second_id| (first_id, second_id)))
  });

  let result_infallible = infallible_transaction(|tx| {
      let first_id = tx.execute(op, 1);
      let second_id = tx.execute(op, 2);
      (first_id, second_id)
  });

    ```
    </Tabs.Tab>
</Tabs>

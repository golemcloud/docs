import { Callout, Tabs } from "nextra/components"

# Forking Agents

## Explanation

Golem agents are single threaded. To achieve parallel execution, it is possible to spawn _child agents_ and communicate with them using RPC, as described on the [Agent to Agent communication page](/develop/rpc).

A simpler way is to use the **fork API**. The fork API consists of a single host function, defined as the following:

<Tabs items={["TypeScript", "Rust"]} storageKey="nextra-tabs-Rust|TypeScript">
<Tabs.Tab>
```typescript
declare module 'golem:api/host@1.1.7' {
  // ...

  /**
   * Indicates which agent the code is running on after `fork`
   */
  export type ForkResult = "original" | "forked";

  /**
   * Forks the current agent at the current execution point.
   * The new agent gets the same base agent ID but with a new unique phantom ID.
   * The phantom ID of the forked agent is returned in fork-result on both sides.
   * The newly created agent continues running from the same point,
   * but the return value is going to be different in this agent and the forked agent.
   */
  export function fork(): ForkResult;
}
```
</Tabs.Tab>

<Tabs.Tab>
`fork` and `ForkResult` can be imported from `golem_rust::fork` and `golem_rust::ForkResult` respectively

```rust
  /**
   * Indicates which agent the code is running on after `fork`
   */
  pub enum ForkResult {
      Original(ForkDetails),
      Forked(ForkDetails),
  }

   /**
   * Forks the current agent at the current execution point.
   * The new agent gets the same base agent ID but with a new unique phantom ID.
   * The phantom ID of the forked agent is returned in fork-result on both sides.
   * The newly created agent continues running from the same point, but the return value is going to be different
   * in this agent and the forked agent.
   */
   fn fork(): ForkResult;
```
</Tabs.Tab>
</Tabs>

## Usage

Using this `fork` function from a component that was created from Golem's built-in templates is straightforward because access to the Golem specific host functions is already set up.

The following code snippet demonstrates calling `fork` and continuing on two different parallel branches based on its result value:

<Tabs items={["TypeScript", "Rust"]} storageKey="nextra-tabs-Rust|TypeScript">
  <Tabs.Tab>
  ```typescript
  import { BaseAgent, agent } from '@golemcloud/golem-ts-sdk';
  import { fork, type ForkResult } from "golem:api/host@1.1.7"

  @agent()
  class ExampleAgent extends BaseAgent {
    name: string;

    constructor(name: string, mode: "root" | "fork") {
      super();
      this.name = name;
    }

    run() {
      switch (fork(`example-agent("${this.name}",fork)`)) {
        case "original": {
          // ...
          break;
        }
        case "forked": {
          // ...
          break;
        }
      }
    }
  }
  ```
  </Tabs.Tab>
  <Tabs.Tab>
  ```rust
use golem_rust::bindings::golem::api::host::create_promise;
use golem_rust::ForkResult;
use golem_rust::{
    agent_definition, agent_implementation, await_promise_json, complete_promise_json, fork,
};

#[agent_definition]
pub trait ExampleAgent {
    fn new(id: String) -> Self;
    fn run(&self) -> Result<(), String>;
}

struct ExampleAgentImpl {
    id: String,
}

#[agent_implementation]
impl ExampleAgent for ExampleAgentImpl {
    fn new(id: String) -> Self {
        ExampleAgentImpl { id }
    }

    fn run(&self) -> Result<(), String> {
        let promise_id = create_promise();

        match fork() {
            ForkResult::Original(_) => {
                // ... do some more work;

                Ok(())
            }
            ForkResult::Forked(_) => {
                // do some work in parallel to the original agent

                Ok(())
            }
        }
    }
}
  ```
  </Tabs.Tab>
</Tabs>

## Join

Once the agent has been forked, the two agent instances are running simultaneously and independently. [Golem promises](/develop/promises) provide a way to resynchronize the two agents.

The high level idea is the following:

- The original agent creates a Golem promise and stores the resulting `PromiseId` in a variable.
- Then forks the new agent. Both the new and the old agents have the promise id.
- When the new agent is done with the work it was forked for, it completes the promise and includes some arbitrary payload it wants to send back to the original agent.
- The original agent, after doing some additional work in parallel to the forked one, can suspend its execution to wait for the promise to be completed. When the promise is completed, the original agent resumes execution and receives the payload sent by the forked agent.

The following code snippet demonstrates this pattern:


<Tabs items={["TypeScript", "Rust"]} storageKey="nextra-tabs-Rust|TypeScript">
  <Tabs.Tab>
  ```typescript
  import { BaseAgent, agent } from '@golemcloud/golem-ts-sdk';
  import { awaitPromise, completePromise, createPromise, PromiseId, fork, type ForkResult } from "golem:api/host@1.1.7"

  @agent()
  class ExampleAgent extends BaseAgent {
    name: string;

    constructor(name: string, mode: "root" | "fork") {
      super();
      this.name = name;
    }

    async run() {
      const promiseId: PromiseId = createPromise();

      switch (fork()) {
        case "original": {
          const localResult = ...; // ... do some more work;

          const rawForkResult: UInt8Array = await awaitPromise(promiseId);
          const forkResult = JSON.parse(new TextDecoder().decode(rawForkResult));

          // Merge localResult and forkResult and continue running
          break;
        }
        case "forked": {
          const result = ...; // do some work in parallel to the original agent

          const rawResult: UInt8Array = new TextEncoder().encode(JSON.stringify(result));
          completePromise(promiseId, rawResult);

          // Stop execution
          break;
        }
      }
    }
  }
  ```

  <Callout type="warning">
  Note that **Golem Promises** are NOT JavaScript Promises, and the API to create, complete and await them is currently **blocking**.
  </Callout>

  </Tabs.Tab>
  <Tabs.Tab>
  ```rust
use golem_rust::bindings::golem::api::host::create_promise;
use golem_rust::ForkResult;
use golem_rust::{
    agent_definition, agent_implementation, await_promise_json, complete_promise_json, fork,
};
use serde::Deserialize;
use serde::Serialize;

struct ExampleAgentImpl {
    id: String,
}

#[derive(Serialize, Deserialize)]
struct RunResult {
    message: String,
}

#[agent_definition]
pub trait ExampleAgent {
    fn new(id: String) -> Self;
    fn run(&self) -> Result<(), String>;
}

#[agent_implementation]
impl ExampleAgent for ExampleAgentImpl {
    fn new(id: String) -> Self {
        ExampleAgentImpl { id }
    }

    fn run(&self) -> Result<(), String> {
        let promise_id = create_promise();

        match fork() {
            ForkResult::Original(_) => {
                let local_result = RunResult {
                    message: format!("Hello from original agent with id: {}", self.id),
                };

                let forked_result: RunResult =
                    await_promise_json(&promise_id).map_err(|err| err.to_string())?;

                println!("local result : {}", local_result.message);
                println!("forked result: {}", forked_result.message);

                Ok(())
            }
            ForkResult::Forked(_) => {
                let result = RunResult {
                    message: format!("Hello from forked agent with id: {}", self.id),
                };

                println!("forked result : {}", result.message);

                complete_promise_json(&promise_id, result).map_err(|err| err.to_string())?;

                Ok(())
            }
        }
    }
}


  ```
  </Tabs.Tab>
</Tabs>
# Worker to Worker communication

## Concept

Golem allows creating and invoking **workers** through it's [REST API](/docs/rest-api/worker) or [command-line interface](/docs/golem-cli), using the rules defined on the [template interface](/docs/template-interface) page. These methods are for working with Golem workers from the outside world - the public API for calling one worker from another is not convenient enough.

Golem instead introduces a new way to do worker-to-worker communication, using a method called **WASM RPC**. This consists of the following building blocks:

- Golem provides a **host resource** for workers, which can be imported into any Golem project and used to invoke a remote worker by passing the target worker, the name of the invoked function and its parameters in a dynamic way using a data type called `wit-value`.
- A CLI tool called `wasm-rpc-stubgen` can take any Golem worker, and generate a pair of a WIT definition and a WASM component implementing a "stub" for remotely calling that given worker. The generated stub internally uses the above mentioned low-level invocation API, providing a typed interface for working with a remote Golem worker.
- The generated stub can be **composed** with other Golem workers using standard WASM tooling to get a resulting WASM ready to be uploaded as a Golem template, capable of typed worker-to-worker communication.

## Details

### Low-level interface

The low-level host interface this technique uses is defined in [wasm-rpc.wit](https://github.com/golemcloud/golem-wit/blob/main/wit/deps/wasm-rpc/wasm-rpc.wit) as the following:

```rust
package golem:rpc@0.1.0;

interface types {
  type node-index = s32;

  record wit-value {
    nodes: list<wit-node>,
  }

  variant wit-node {
    record-value(list<node-index>),
    variant-value(tuple<u32, option<node-index>>),
    enum-value(u32),
    flags-value(list<bool>),
    tuple-value(list<node-index>),
    list-value(list<node-index>),
    option-value(option<node-index>),
    result-value(result<option<node-index>, option<node-index>>),
    prim-u8(u8),
    prim-u16(u16),
    prim-u32(u32),
    prim-u64(u64),
    prim-s8(s8),
    prim-s16(s16),
    prim-s32(s32),
    prim-s64(s64),
    prim-float32(float32),
    prim-float64(float64),
    prim-char(char),
    prim-bool(bool),
    prim-string(string),
  }

  record uri {
    value: string,
  }

  variant rpc-error {
    protocol-error(string),
    denied(string),
    not-found(string),
    remote-internal-error(string)
  }

  resource wasm-rpc {
    constructor(location: uri);

    invoke-and-await: func(function-name: string, function-params: list<wit-value>) -> result<wit-value, rpc-error>;
  }
}

world wit-value {
    import types;
}
```

### Worker URI

The **worker URI** that has to be passed to the remote interface as a parameter identifies a specific **Golem worker**, consisting of the **template ID** and the **worker name**.
It can be constructed by hand using the pattern `worker://template-id/worker-name`, and a running worker can get it's own URI using the Golem-specific host function `golem:api/host/get-self-uri`.

### Stub generator

The latest version of the stub generator can be installed using:

```shell
cargo install golem-wasm-rpc-stubgen
```

Once it's installed, it provides the following command:

```
Golem WASM RPC stub generator

Usage: golem-wasm-rpc-stubgen generate [OPTIONS] --source-wit-root <SOURCE_WIT_ROOT> --dest-crate-root <DEST_CRATE_ROOT>

Options:
  -s, --source-wit-root <SOURCE_WIT_ROOT>
  -d, --dest-crate-root <DEST_CRATE_ROOT>
  -w, --world <WORLD>
      --stub-crate-version <STUB_CRATE_VERSION>          [default: 0.0.1]
      --wasm-rpc-path-override <WASM_RPC_PATH_OVERRIDE>
  -h, --help                                             Print help
  -V, --version                                          Print version
```

The parameters have the following meaning:

- `--source-wit-root` must point to the directory of the WIT specification of the **worker to be called remotely**. This is usually a `wit` subdirectory in the worker's template's source code.
- `--dest-crate-root` is a new directory where the generated RPC stub will be put. The tool's current version does not generate a WASM file directly, instead it outputs a complete Rust crate which can be compiled via `cargo component build` (as described on the [Rust page](/docs/building-templates/tier-2/rust)) or included in a Rust workspace.
- `--world` can be used to select the exported world from the source WIT, if there are more than one. If there is only one world defined, there is no need to use this parameter.
- `--stub-crate-version` sets the generated Rust crate's version to the given value.
- `--wasm-rpc-path-override` is useful when working on the `wasm-rpc` crate itself, to point the dependency to a local path instead of using the published version.

The generated crate will contain a new WIT file - named `wit/_stub.wit` - which contains all the exported functions, interfaces and resources from the _source worker's WIT specification_, but each of them is packaged into an exported **resource** representing the remote connection to a specific remote worker. The generated Rust code implements these exported resources using the low-level invocation interface defined above.

For example if the original worker's WIT exported an interface and a resource through a function:

```rust
package golem:component;

interface api {
  resource counter {
    constructor(name: string);
    inc-by: func(value: u64);
    get-value: func() -> u64;

    merge-counters: static func(counter1: counter, counter2: counter, name: string) -> counter;
  }

  get-all-counters: func() -> list<counter>;
}

world my-world {
  export api;
}
```

The generated stub WIT specification for the above interface will be:

```rust
package golem:component-stub;

interface stub-my-world {
  use golem:rpc/types@0.1.0.{uri};

  resource api {
    constructor(location: uri);
    get-all-counters: func() -> list<counter>;
  }

  resource counter {
    constructor(location: uri, name: string);
    inc-by: func(value: u64);
    get-value: func() -> u64;
    merge-counters: static func(counter1: counter, counter2: counter, name: string) -> counter;
  }

}

world wasm-rpc-stub-my-world {
  export stub-my-world;
}
```

Each exported interface and resource becomes a new **resource**, accepting a remote worker URI as a parameter.

## Example steps

The current state of wasm-rpc tooling still requires some manual steps:

1. Generate the stub crate for the worker to be called, for example:

```
golem-wasm-rpc-stubgen generate --source-wit-root counters/wit --dest-crate-root counters-stub
```

2. Copy the generated stub crate's `wit/deps` directory to the **caller worker**'s `wit/deps` directory:

```
cp -rv counters-stub/wit/deps/* caller/wit/deps
```

3. Copy the generated `_stub.wit` to the **caller worker**'s `wit/deps/counters-stub` directory:

```
cp counters-stub/wit/_stub.wit caller/wit/deps/counters-stub/stub.wit
```

4. Add both the remote worker's and the stub's package as a dependency into the caller worker's `Cargo.toml`:

```
"rpc:counters" = { path = "wit/deps/rpc_counters" }
"rpc:counters-stub" = { path = "wit/deps/counters-stub" }
```

5. Use the generated stub to call remote workers, for example:

```rust
use crate::bindings::rpc::counters_stub::stub_counters::Counter;

let template_id = env::var("COUNTERS_TEMPLATE_ID").expect("COUNTERS_TEMPLATE_ID not set");
let counters_uri = Uri { value: format!("worker://{template_id}/counters_test1") };

let counter1 = Counter::new(counters_uri, "counter1");
counter1.inc_by(1);
let value1 = counter1.get_value();
```

Note it is a good practice to pass the called worker's **template id** as an environment variable to the caller worker.

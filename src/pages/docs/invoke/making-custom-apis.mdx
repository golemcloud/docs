# Making custom APIs

The [Worker Gateway](/docs/concepts/worker-gateway) service not only exposes the [low-level REST API for invocations](/docs/invoke/http) but also provides a way to define fully customizable HTTP APIs.
Future versions will support other protocols as well such as gRPC or GraphQL.

- [Define](making-custom-apis/define-api-definition) an HTTP API definition
- [Register/Upload](making-custom-apis/register-api-definition) the API definition with Golem Gateway
- [Deploy] the API definition with Golem Gateway
- [Try out](making-custom-apis/try-out-deployed-api) the deployed API
- [Troubleshooting](making-custom-apis/trouble-shooting) the deployment
- [Make your APIs secure](making-custom-apis/authentication)
- Setting up CORS in API Gateway
- Automatic [Spec Inference](making-custom-apis/spec-inference) of required inputs for API Endpoint based on Rib script
- REST API to deploy API
- More details on Response Mapping
- Looking up data from the request body and path
- Input `request`

## Setting up CORS in API Gateway

Setting up CORS in API gateway is simple. Simplify specify the preflight request endpoint for your resource and all the operations
under the resource is now CORS enabled. This is mostly inspired from AWS API Gateway approach.

Here is an example of how to setup CORS for your API definition.

```bash filename="Terminal" copy
    id: users-api
    version: 0.0.1
    createdAt: 2024-08-21T07:42:15.696Z
    routes:
    - method: Options
      path: /users/{user-id}
      binding:
      bindingType: cors-preflight
    - method: Get
      path: /users/{user-id}
      binding:
      response: |
        {status: 200u64, body: "Hello World"}
```

Here we define the preflight request endpoint for `/users/{user-id}` as `Options` method.
This is used by browsers to check if the actual request is allowed.
Registering this API definition will ensure that the other operations (in the above example, Get)
will also be CORS enabled with required headers in the response.

We can define a custom response for the preflight request as well using Rib as given below

```bash filename="Terminal" copy
    id: users-api
    version: 0.0.1
    createdAt: 2024-08-21T07:42:15.696Z
    routes:
    - method: Options
      path: /users/{user-id}
      binding:
      bindingType: cors-preflight
      response: |
        {
          Access-Control-Allow-Origin: "*",
          Access-Control-Allow-Methods: "GET, POST, PUT, DELETE, OPTIONS",
          Access-Control-Allow-Headers: "Content-Type, Authorization",
          Access-Control-Expose-Headers: "Content-Length, X-Requested-With",
          Access-Control-Allow-Credentials: true,
          Access-Control-Max-Age: 86400u64
        }
    - method: Get
      path: /users/{user-id}
      binding:
      response: |
        {status: 200u64, body: "Hello World"}
```

## REST API to deploy API

As of now, we have deployed the API using golem-cli.
We can do the same using REST APIs as an alternative.

For this, let's create a `deployment.json` as given below.
Based on the example above, the apiDefinitionId is `shopping-cart-v1` and version is `0.0.4`.

If you were having a domain registered such as `my-site.com`, you would replace `localhost:9006` with `my-site.com`,
that in turn redirects to `localhost:9006`, or wherever the worker-service is running (perhaps AWS).

```json
{
  "apiDefinitions": [
    {
      "id": "my-shopping-cart-v1",
      "version": "0.0.6"
    }
  ],
  "site": {
    "host": "locahost:9006"
  }
}
```

`subdomain` field under `site` is optional. But you can provide this if its backed by a valid `host`.
For `localhost` subdomain doesn't make much sense.

```bash filename="Terminal" copy

curl -X POST http://localhost:9881/v1/api/deployments/deploy -H "Content-Type: application/json"  -d @api-deployment.json

{"apiDefinitions":[{"id":"my-shopping-cart-v1","version":"0.0.4"}],"createdAt":"2024-10-31T07:59:00.390103588+00:00","site":{"host":"locahost:9006","subdomain":null}}‚èé
```

## More details on Response Mapping

Response Mapping is under the `response` field under each binding. This is written using [Rib](/docs/rib) to call the worker function and manipulate it's results and return a value that's understandable for each protocol we use.

Here is a more complex example of an API definition that gives you more idea on
what can be achieved with Rib expression under response field.

Please use this as a reference instead of using it with zero changes.

```json
{
  "id": "my-shopping-cart-v2",
  "draft": true,
  "version": "2.0.11",
  "routes": [
    {
      "method": "Get",
      "path": "/{user-id}/get-cart-contents",
      "binding": {
        ..
        "workerName": "\"my-worker\"",
        "response": "let result = golem:it/api.{get-cart-contents}(); {status: 200u64, body: result}"
      }
    },
    {
      "method": "Post",
      "path": "/{user-id}/initialize-cart",
      "binding": {
        ..
        "workerName": "\"my-worker\"",
        "response": "let empty: list<u16> = []; ${golem:it/api.{initialize-cart}(request.path.user-id); {status: 200u64, body: empty}}"
      }
    },
    {
      "method": "Post",
      "path": "/{user-id}/add-item",
      "binding": {
        ..
        "workerName": "\"my-worker\"",
        "response": "let quantity: f64 = request.body.quantity; let product_id: u64 = request.body.product-id; let name: string = request.body.name; let price: f64 = request.body.price; let input = {product-id: product_id, name: name, price: price, quantity: quantity}; golem:it/api.{add-item}(input); {status: 200u64, body: \"success\"}"
      }
    },
    {
      "method": "Post",
      "path": "/{user-id}/checkout",
      "binding": {
        ..
        "workerName": "\"my-worker\"",
        "response": "let result = golem:it/api.{checkout}(); {status: 200u64, body: match result { success(resp) => resp.order-id, error(msg) => msg }}"
      }
    }
  ]
}
```

This example exposes multiple functions of the shopping-cart component through a custom HTTP API.
Some of these examples include longer Rib scripts under `response` field. Also since you are not using `golem console` (from golem cloud),
and relying on directly encoding `Rib` in a Http request, everything had to be in 1 single line, since multi-line doesn't work in JSON
body in http request. Improvements in this space are in progress.

Note that each line in Rib code block is separated by `;` and the last line in the Rib script is the return value which shouldn't have `;`.

Most of the above examples are self explanatory, but worth pointing out a few details.

Some of the `response` fields above have Rib script where we pass parameters to the function.
This is more or less same as many programming languages - a comma separated list of arguments.
Arguments are valid Rib code.

```bash filename="Terminal" copy

golem:it/api.{initialize-cart}(request.path.user-id)

```

Here Rib compiler knows the requirement of initialize-cart function and infers that request.path.user-id should be u64.
This is a hint, that Rib is aware of the types in the code. In places where it find hard to infer these types, you may face
some compile time errors (when uploading API definition), and the best solution is to be explicit about types. For example

```bash filename="Terminal" copy
let user_id: u64 = request.path.user-id;
golem:it/api.{initialize-cart}(user_id)

```

The most interesting example out of all the endpoints is the `checkout` endpoint.

Here the response mapping in Rib is this:

```bash filename="Terminal" copy
let result = golem:it/api.{checkout}();

{status: 200u64, body: match result { success(resp) => resp.order-id, error(msg) => msg }}

```

This can also be written as the following for more readability (with [golem console](https://console.golem.cloud):

```
let result = golem:it/api.{checkout}();
let status: u64 = 200;
let body =  match result { success(resp) => resp.order-id, error(msg) => msg };
{status: status, body: body}

```

Here we manipulate the result from worker function using a match expression. More details on match expression is explained under [Rib](/docs/rib) documentation.
It matches on `success` and `error` variants because the result type of `golem:it/api.{checkout}` is a variant which can be either success or error.

## Looking up data from the request body and path

In the above example, we have an endpoint to add products into the cart.

```json
{
  "method": "Post",
  "path": "/{user-id}/add-item",
  "binding": {
    ....
    "response": "${let product_id: u64 = request.body.product-id; golem:it/api.{add-item}({product-id: product_id}); let empty_body: list<u16> = []; {status: 200u64, body: empty_body}}"
  }
}
```

This implies, the http request should be method `POST` with request body having the following fields: `product-id`, `name`, `price` and `quantity`.

## Input `request`

Worker gateway allows you to look up the values of request path or query variables using `request.path.*` syntax.
For request body, you can use `request.body.*` syntax. Similarly for headers it is `request.headers.*`

## Constraints on Components after deployment

Please note that, once you have deployed an API using a specific component-version, then
you may not be able to update the component-version (ex: `golem-cli component update`) unless
the arguments to the functions used in the Rib script in the deployed API definition is backward compatible.

If there are conflicts (i.e, backward incompatible) then you will get a conflict report message,
which details especially the missing functions and conflicting functions, where conflicting functions
detail about existing parameter types, new parameter types, existing return type, and new return type.

## Support to import OpenAPI spec

Until now, we used the native API definition format of Golem.
Golem allows you to import API definition in OpenAPI spec format too.
This is because, users may have already written an OpenAPI spec for their endpoints for various purposes.
By adding extra details of into the same spec, we can use it as an API definition. Internally it gets converted to the Worker Gateway's native format of API definition, discussed in the beginning of this documentation.

The main advantage of this feature is the re-usability of the same endpoint definitions across your system. For example, you can use the same file now to register with Golem's Worker Gateway and register with another external API gateway. More on this below. However once deployed, it returns native format then onwards, and updates needs to be done in the native format.

```json
openapi: 3.0.0
info:
  title: MyOpenAPISpec
  version: 1.0.2
x-golem-api-definition-id: my-shopping-cart-v1
x-golem-api-definition-version: 0.0.7
paths:
  /{user-id}/get-cart-contents:
    get:
      x-golem-worker-bridge:
        worker-name: '"foo"'
        component-id: dba38841-013a-49fa-a1dc-064949832f0c
        component-version: 0
        response: |
            let x = golem:it/api.{checkout}();
            let status: u64 = 200; {headers : {ContentType: "json", userid: "foo"}, body: "foo", status: status}
      summary: Get Cart Contents
      description: Get the contents of a user's cart
      parameters:
        - name: user-id
          in: path
          required: true
          schema:
            type: string
      responses:
        200:
          description: OK
          content:
            application/json:
              schema:
                $ref: "#/components/schemas/CartItem"
        404:
          description: Contents not found
components:
  schemas:
    CartItem:
      type: object
      properties:
        id:
          type: string
        name:
          type: string
        price:
          type: number

```

To import OpenAPI spec using Golem CLI,

```bash filename="Terminal" copy

golem-cli api-definition import open_api.json

```

This will return

```bash filename="Terminal" copy

{
  "id": "my-shopping-cart-v1",
  "version": "0.0.7",
  "routes": [
    {
      "method": "Get",
      "path": "/{user-id}/get-cart-contents",
      "binding": {
        "componentId": {
          "componentId": "dba38841-013a-49fa-a1dc-064949832f0c",
          "version": 0
        },
        "workerName": "\"foo\"",
        "idempotencyKey": null,
        "response": "let x = golem:it/api.{checkout}();\nlet status: u64 = 200;\n{headers: {ContentType: \"json\", userid: \"foo\"}, body: \"foo\", status: status}",
        "responseMappingInput": {
          "types": {}
        },
        "workerNameInput": {
          "types": {}
        },
        "idempotencyKeyInput": null
      }
    }
  ],
  "draft": true,
  "createdAt": "2024-10-31T08:56:02.412860043Z"
}

```

## Integrating worker-gateway with existing API Gateways

Note that, while the Golem's Worker Gateway is a powerful tool for defining and managing API endpoints, it is not a full-fledged API Gateway.
However, it can be used conjunction with existing API Gateways, allowing you to leverage the capabilities of both systems.
For example, you can use Golem's Worker Gateway to define and manage the worker bindings for your API endpoints, while using an API Gateway to handle other aspects of API management, such as authentication, rate limiting, and monitoring.
In this scenario, the third party API Gateway would route incoming requests to Golem based on the defined endpoints, allowing Golem's Worker Gateway to handle the request processing and response generation.

### Tyk

This section shows how to integrate with [Tyk API gateway](https://tyk.io).

Note that Tyk allows users to upload OpenAPI spec similar to Golem. You can upload the same OpenAPI spec with worker-gateway info to Tyk,
with 1 more extra information which is `servers` block with the value of the URL of the Golem Worker Gateway (which is the URL of the worker-service service in docker),
that tells the Tyk API gateway of Tyk to route the request to worker-gateway.

Please note, the above set up will work depending on how you installed Tyk.
If you installed Tyk in the same network as worker-gateway, you can use the localhost as servers.

If you are using a separate docker network with Tyk, you will need to give the machine IP address to reach the Worker Gateway URL.

```json
openapi: 3.0.0
x-golem-api-definition-version: 0.0.3
x-golem-api-definition-id: shopping-cart-v1
info:
  title: Sample API
  version: 1.0.2
servers:
  - url: http://ip-address-of-your-local-machine:9881
paths:
  /{user-id}/get-cart-contents:
    x-golem-worker-bridge:
      worker-name: '"foo"'
      component-id: dba38841-013a-49fa-a1dc-064949832f0c
      component-version: 0
      response: |
        let x = golem:it/api.{checkout}();
        let status: u64 = 200; {headers : {ContentType: "json", userid: "foo"}, body: "foo", status: status}
    get:
      summary: Get Cart Contents
      description: Get the contents of a user's cart
      parameters:
        - name: user-id
          in: path
          required: true
          schema:
            type: string
      responses:
        200:
          description: OK
          content:
            application/json:
              schema:
                $ref: "#/components/schemas/CartItem"
        404:
          description: Contents not found
components:
  schemas:
    CartItem:
      type: object
      properties:
        id:
          type: string
        name:
          type: string
        price:
          type: number

```

The difference here is we added the server's block. You can include this servers block from the beginning
so that it's exactly the same OpenAPI spec which you used to upload to Golem as well as Tyk.

#### Install Tyk

```bash filename="Terminal" copy
git clone https://github.com/TykTechnologies/tyk-gateway-docker
cd tyk-gateway-docker
docker-compose up
```

#### Registration with Tyk

Let's say we saved the above json as open_api.json

```bash filename="Terminal" copy
curl -X POST http://localhost:8080/tyk/apis/oas/import --header 'x-tyk-authorization: foo' --header 'Content-Type: text/plain' -d @open_api.json

```

Reload the Tyk API Gateway, otherwise the API is not deployed with Tyk yet, so this is an important step.
Note that, if you are encountering issues following these steps, please refer to Tyk documentations.

```bash
curl -H "x-tyk-authorization: foo" -s http://localhost:8080/tyk/reload/group

```

Note that Tyk is now running at 8080, and now requests has to go into 8080 and not the Golem Worker Gateway.

```bash filename="Terminal" copy
curl -X GET http://localhost:9006/adam/get-cart-contents
```

## FAQ

**How does worker service know which API definition to pick for a given endpoint?**

When a request comes in, worker-service looks at the host in the request and matches it with the site in the deployment.
If there is a deployment corresponding to the site, it picks the API definition ID and version from the deployment and gets the API definition,
to further process the request

import { Callout, Card, Cards, Tabs, Steps } from "nextra/components"

# Quickstart

This guide will get you up and running in Golem in minutes.

### Install Golem CLI

Golem CLI is a command-line application that allows you to deploy components,
create and invoke agents, and otherwise manage your Golem applications.

There are **precompiled binaries** of `golem` (and its other variants) for
various platforms. Alternatively, you can [build Golem CLI for yourself](/cli/install-from-source).

#### Precompiled binaries

You can download the full version of `golem` from the following page:

<Cards num={1}>
  <Card
    title="Golem CLI Releases"
    href="https://github.com/golemcloud/golem/releases"
  />
</Cards>

There are precompiled binaries of two variants of the CLI here:

- `golem` is the full version of the command line interface, including a locally runnable version of Golem itself.
- `golem-cli` is a lightweight version of the command line interface, requiring a running Golem cluster

In this documentation we will use the `golem` command in the snippets. The available commands of (except the one for starting up the local Golem cluster) are the same in both variants.

### Running Golem

It is possible to test Golem locally without installing anything else than the above described `golem` executable. To use it, start the local Golem cluster by running the following command:

```shell copy
golem server run
```

To use the open source version of Golem in production you will need to deploy it in your own infrastructure. See the [deployment](deploy) page for available deployment options.

It is also possible to use our _hosted version_ of Golem, available at [https://console.golem.cloud].


### Building an Example

Golem runs components that are WebAssembly programs implementing **agents**. Every component contains defines one or more **agent types**, and golem runs stateful, durable instances of these agent types that we call agents.
applications, except they may expose functions that can be called externally.

The `golem` command line interface provides integrates a set of commands to create, build, and deploy components.

To get started, you create an application and a single component using one of the supported programming languages with the `golem app new` command. If no additional parameters are provided, the command will interactively ask for all required information.

<Tabs items={["TypeScript"]}>
  <Tabs.Tab>
  Create TypeScript agent using the default template:

  ```shell copy
  golem app new

  > Application name: agent-examples
  > Select language for the new component TypeScript
  > Select a template for the new component: default: The default agent template for TypeScript
  > Component Package Name: example:counter
  > Add another component or create application? Create application
  ```

  Note: for TypeScript, you need to have `npm` installed on your system.
  </Tabs.Tab>
</Tabs>

This will generate a new component in a new directory of the provided application name, and it is ready to be compiled and deployed to Golem.

To **build** the newly created component, use the following command:

```shell copy
golem app build
```

This compiles the newly created application, which consists of a _single Golem component_ at the moment. An application can have multiple components, each implementing a different set of agent types. New components can be added to the application by using the `golem component new` command.

### Write the code

<Tabs items={["TypeScript"]}>
  <Tabs.Tab>
The default template's source code is located in `components-ts/example-counter/src/main.ts` file, assuming that the `example:counter` name has been used in the `app new` command. The directory structure allows applications to have multiple components, even implemented in multiple programming languages if needed.

Let's use the following code snippet for this example:

```typescript
import {
    BaseAgent,
    agent,
    prompt,
    description,
} from '@golemcloud/golem-ts-sdk';

@agent()
class CounterAgent extends BaseAgent {
    private readonly name: string;
    private value: number = 0;

    constructor(name: string) {
        super()
        this.name = name;
    }

    @prompt("Increase the count by one")
    @description("Increases the count by one and returns the new value")
    async increment(): Promise<number> {
        this.value += 1;
        return this.value;
    }
}
```

  </Tabs.Tab>
</Tabs>

In this simple example we define a very simple agent that is identified by a `name` string, and exposes a single agent method `increment` that increments the count by one and returns the new value.
This is a simple example of an agent that does not communicate with other agents or external services, but has state.

### Uploading Your Component

To upload your component to Golem, you can use the `app deploy` command.

```shell copy
golem app deploy
```

When you add a component you will see some basic information about the component such as its name, unique identifier, version, and size. In addition, you will see a list of exports. These are the exported agent types of the component.

Uploading a component to Golem does not actually execute the component. Instead, it only makes it available for execution to Golem.

Every separate running instance of your component is referred to as an _agent_, based on one of the agent types implemented by that component.

### Create Agents

In Golem, every agent has a unique id that has a specific format: it consists of the _agent type_ followed by the values passed to the agent's constructor.

There are individual CLI commands to create agents and invoke agent methods, where this agent name is used to identify the agent.

For testing purposes, it is much easier to use the **Golem REPL** to create agents and interact with them.

First start the REPL using:

```shell copy
golem repl
```

The REPL uses a special scripting language called [Rib](rib). We can create some counter agents and interact with them using the following commands:

```shell copy
>>> let a1 = counter-agent("agent-1")
()
>>> let a2 = counter-agent("another")
()
>>> a1.increment()
1
>>> a1.increment()
2
>>> a2.increment()
1
```

Note that the REPL provides autocompletion on Tab.

Check the [Invoke section](invoke) to learn about more about other ways to invoke agents.

### Expose a HTTP API

Agents can be invoked from other agents, through the REPL or CLI, or Golem's Invocation API, but Golem Applications can also define **HTTP APIs** that map routes to agents and agent methods.

To finish the QuickStart example with a HTTP POST endpoint for tracking counts, let's open the `golem.yaml` file in the component's directory. It's going to contain a a `components` and a `dependencies` section already.

To define the HTTP API, we add its definition and information about how to expose it:

```yaml
httpApi:
  definitions:
    counter-api:
      version: '0.0.1'
      routes:
        - method: POST
          path: /{name}/increment
          binding:
            type: default
            componentName: "example:counter"
            response: |
              let name: string = request.path.name;
              let agent = counter-agent(name);
              let new-value = agent.increment();
              { status: 200, body: { result: "incremented ${name}, new value is ${new-value}" } }

  deployments:
    local:
    - host: localhost:9006
      definitions:
       - counter-api
```

Then use the `golem` CLI to deploy this API:

```shell copy
golem api deploy
```

After this command, the API is deployed to our locally running Golem instance and can be tried out by sending POST requests to `http://localhost:9006/{name}/increment`:

```shell copy
curl -X POST http://localhost:9006/agent-1/increment
```

### Notes about the Golem 1.3 release

Read the following important notes about the Golem 1.3 release, especially if you have used previous Golem versions:

<Steps>
#### Changes in naming

  Previously Golem called _agents_ as workers, and the new name has not been applied everywhere yet. The APIs described in this section are still using the _worker_ name.

#### Grouping multiple agent types

  In Golem 1.3, a component can define multiple **agent types**, and it is recommended to put all agent types that are calling each other into the same component. This is a change from previous versions, where one component was implementing one specific worker interface.

  Currently the agent-to-agent RPC is only possible if the caller have access to the called agent type's source.

  It is still possible to have multiple components in an application. There are some component-level settings that may motivate this, such as per-component environment variables and configuration, or the component type (durable or ephemeral). Another possible reason for grouping agent types into separate components can be to apply different update policies to them.

#### Durability while testing locally

  Golem provides durable execution by default, which can be inconvenient when iterating on a code and testing things locally. To start from a fresh state when trying out new changes, one possibility is to restart the local Golem server with `golem server run --clean`. **This deletes all data**. A more fine grained options is to pass `--reset` to CLI options such as `golem agent invoke`. This will delete existing agents and APIs but only for the invoked component.

#### Supported TypeScript types

   The Golem TypeScript SDK supports a subset of TypeScript types when defining agent constructors and methods. See the [type mapping page](/type-mapping) for details. If something is not supported, it is going to be a compile time error. Please report such issues to our [issue tracker](https://github.com/golemcloud/golem/issues).

#### Supported JS APIs

   Only a subset of browser and Node APIs are supported in Golem agents currently. See [the full list](/js-apis) for details. This limits the external libraries that can be used in Golem agents. Please report any important missing APIs to our [issue tracker](https://github.com/golemcloud/golem/issues).

#### RPC cycles

   When calling agents from other agents, the default mode is that the invoked method's result is awaited in the callee. As every agent is single threaded and invocations cannot overlap, it is possible to create a deadlock if agents are invoking each other in a cycle. This can be fixed by not awaiting the invocation, but instead just _trigger_ the invocation (or schedule for later). See the [agent-to-agent communication page](/develop/rpc) for details.

#### AI libraries

   Golem 1.3 comes with a suite of libraries for building AI agents. See the [AI libraries page](/develop/ai) for details. When importing one of these libraries in the agent's code, don't forget to also **specify the implementation** in the `golem.yaml` file, as described on the AI libraries page. The agent templates are coming with commented out sections in the application manifest (`golem.yaml`) for all the supported libraries.
</Steps>


### Next Steps

In this guide, you have learned how to build and deploy invincible serverless agents on Golem, and seen how you can interact with them as they execute.

Take your next steps with Golem by exploring the following resources:

- Read about the [fundamentals of Golem](fundamentals)
- Learn about the [main concepts](concepts)
- Read everything [developing Golem applications](develop)
- Check out how to [deploy](deploy) Golem to your infrastructure
- Read the details of how to [invoke workers](invoke)
- Learn more about the [Golem CLI](cli)
- Explore operational aspects such as [how worker state is persisted](operate/persistence), what [metrics](operate/metrics) and [logs](operate/logs) are available
- Check the **References** section for detailed information on APIs and syntaxes
